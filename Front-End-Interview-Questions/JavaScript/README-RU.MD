# Вопросы по JavaScript

## 1 Что такое прототипное наследование? Как оно работает?

Прототипное наследование - это наследование свойств и методов обьекта родителя путем присваивание его к скрытому свойству "Prototype" экземпляра обьекта;

Обьекты в JavaScript содержат скрытое свойство "Prototype", к каторому можно присвоить другой обьект;

При вызове свойства обьекта оно сначала ищется у него самого, а потом ищется у его родителей через цепочку прототипов, до того пока свойство не будет найдено или прототип не будет равен null, тогда вернется undefined.

Пример A:
```JavaScript
    const a = {
        name: "Dima"
    }

    const b = {}

    b.__proto__ = a;

    console.log(b.name); // Dima
```

Переопределение свойства родительского обьекта приводит к создании копии этого свойства в текущем обьекте.

Пример B:
```JavaScript
    // ... Пример A

    b.name = "Roma";

    console.log(b.name); // Roma
    console.log(b.__proto__.name); // Dima
```

При вызове родительского метода this, внутри него, указывает на текущий обьект: поиск свойства у this происходит через цепочку прототипов.

Пример C:
```JavaScript
    // ... Пример B

    a.sayHi = function() {
        return "Привет " + this.name + "!";
    }

    console.log(b.sayHi()); // Привет Roma!
    console.log(b.__proto__.sayHi()); //  Привет Dima!
```

Цепочка прототипов может быть длиннее:
```JavaScript
    const a = { name: "Dima" }
    const b = { age: 23, __proto__: a }
    const c = { hairColor: "Brown", __proto__: b }

    // name взят из цепочки прототипов
    console.log(c.name); // Dima
    console.log(b.age); // 23 (из обьекта b)
```

Операция записи не использует прототип - Прототип используется только для чтения свойств. Операции записи/удаления работают напрямую с объектом.

В приведённом ниже примере мы присваиваем rabbit собственный метод walk:
```JavaScript
    let animal = {
        eats: true,
        walk() {
            /* этот метод не будет использоваться в rabbit */
        }
    };

    let rabbit = {
        __proto__: animal
    };

    rabbit.walk = function() {
        alert("Кролик! Прыгает!");
    };

    rabbit.walk(); // Кролик! Прыгает!
```

Свойства-аксессоры – исключение, так как запись в него обрабатывается функцией-сеттером. То есть это фактически вызов функции.

По этой причине admin.fullName работает корректно в приведённом ниже коде:
```JavaScript
    let user = {
        name: "Dima",
        surname: "Chekashov",

        set fullName(value) {
            [this.name, this.surname] = value.split(" ");
        },

        get fullName() {
            return `${this.name} ${this.surname}`;
        }
    };

    let admin = {
        __proto__: user,
        isAdmin: true
    };

    alert(admin.fullName); // Dima Chekashov (*)

    // срабатывает сеттер!
    admin.fullName = "Roma Chekashov"; // (**)
    alert(admin.name); // Roma
    alert(admin.surname); // Chekashov
```
Здесь в строке (*) свойство admin.fullName имеет геттер в прототипе user, поэтому вызывается он. В строке (**) свойство также имеет сеттер в прототипе, который и будет вызван.

Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.

Например:
```JavaScript
    let animal = {
        eats: true
    };

    let rabbit = {
        jumps: true,
        __proto__: animal
    };

    // Object.keys возвращает только собственные ключи
    alert(Object.keys(rabbit)); // jumps

    // for..in проходит и по своим, и по унаследованным ключам
    for(let prop in rabbit) alert(prop); // jumps, затем eats
```

Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.

#### Итого

* В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
* Мы можем использовать obj.__proto__ для доступа к нему (исторически обусловленный геттер/сеттер, есть другие способы, которые скоро будут рассмотрены).
* Объект, на который ссылается [[Prototype]], называется «прототипом».
* Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
* Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
* Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
* Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.