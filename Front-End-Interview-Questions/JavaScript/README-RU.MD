# Вопросы по JavaScript

## 1 Что такое прототипное наследование? Как оно работает?

Прототипное наследование - это наследование свойств и методов обьекта родителя путем присваивание его к скрытому свойству "Prototype" экземпляра обьекта;

Обьекты в JavaScript содержат скрытое свойство "Prototype", к каторому можно присвоить другой обьект;

При вызове свойства обьекта оно сначала ищется у него самого, а потом ищется у его родителей через цепочку прототипов, до того пока свойство не будет найдено или прототип не будет равен null, тогда вернется undefined.

Пример A:
```JavaScript
    const a = {
        name: "Dima"
    }

    const b = {}

    b.__proto__ = a;

    console.log(b.name); // Dima
```

Переопределение свойства родительского обьекта приводит к создании копии этого свойства в текущем обьекте.

Пример B:
```JavaScript
    // ... Пример A

    b.name = "Roma";

    console.log(b.name); // Roma
    console.log(b.__proto__.name); // Dima
```

При вызове родительского метода this, внутри него, указывает на текущий обьект: поиск свойства у this происходит через цепочку прототипов.

Пример C:
```JavaScript
    // ... Пример B

    a.sayHi = function() {
        return "Привет " + this.name + "!";
    }

    console.log(b.sayHi()); // Привет Roma!
    console.log(b.__proto__.sayHi()); //  Привет Dima!
```

Цепочка прототипов может быть длиннее:
```JavaScript
    const a = { name: "Dima" }
    const b = { age: 23, __proto__: a }
    const c = { hairColor: "Brown", __proto__: b }

    // name взят из цепочки прототипов
    console.log(c.name); // Dima
    console.log(b.age); // 23 (из обьекта b)
```

Операция записи не использует прототип - Прототип используется только для чтения свойств. Операции записи/удаления работают напрямую с объектом.

В приведённом ниже примере мы присваиваем rabbit собственный метод walk:
```JavaScript
    let animal = {
        eats: true,
        walk() {
            /* этот метод не будет использоваться в rabbit */
        }
    };

    let rabbit = {
        __proto__: animal
    };

    rabbit.walk = function() {
        alert("Кролик! Прыгает!");
    };

    rabbit.walk(); // Кролик! Прыгает!
```

Свойства-аксессоры – исключение, так как запись в него обрабатывается функцией-сеттером. То есть это фактически вызов функции.

По этой причине admin.fullName работает корректно в приведённом ниже коде:
```JavaScript
    let user = {
        name: "Dima",
        surname: "Chekashov",

        set fullName(value) {
            [this.name, this.surname] = value.split(" ");
        },

        get fullName() {
            return `${this.name} ${this.surname}`;
        }
    };

    let admin = {
        __proto__: user,
        isAdmin: true
    };

    alert(admin.fullName); // Dima Chekashov (*)

    // срабатывает сеттер!
    admin.fullName = "Roma Chekashov"; // (**)
    alert(admin.name); // Roma
    alert(admin.surname); // Chekashov
```
Здесь в строке (*) свойство admin.fullName имеет геттер в прототипе user, поэтому вызывается он. В строке (**) свойство также имеет сеттер в прототипе, который и будет вызван.

Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.

Например:
```JavaScript
    let animal = {
        eats: true
    };

    let rabbit = {
        jumps: true,
        __proto__: animal
    };

    // Object.keys возвращает только собственные ключи
    alert(Object.keys(rabbit)); // jumps

    // for..in проходит и по своим, и по унаследованным ключам
    for(let prop in rabbit) alert(prop); // jumps, затем eats
```

Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.

#### Итого

* В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
* Мы можем использовать obj.__proto__ для доступа к нему.
* Объект, на который ссылается [[Prototype]], называется «прототипом».
* Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
* Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
* Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
* Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.

## 2 Обьясните значение `this` в JavaScript

this - это ссылка на некий объект, к свойствам которого можно получить доступ внутри вызова функции. Этот this — и есть контекст выполнения.

```JavaScript
    let user = {
        name: "John",
        age: 30,

        sayHi() {
            // "this" - это "текущий объект".
            alert(this.name);
        }
    };

    user.sayHi(); // John
```

Значение this определяется во время выполнения кода, в зависимости от контекста. Если записать метод объекта в переменную и вызвать её, значение this изменится.

```JavaScript
    const user = {
        name: 'Alex',
        greet() {
            console.log(`Hello, my name is ${this.name}`)
        },
    }

    const greet = user.greet
    greet()
    // Hello, my name is
```

При вызове через точку user.greet() значение this равняется объекту до точки (user). Без этого объекта this равняется глобальному объекту. В строгом режиме мы бы получили ошибку «Cannot read properties of undefined».

Чтобы такого не происходило, следует использовать bind().

### Вызов конструктора

При вызове конструктора this равен свежесозданному объекту.

В примере с User значением this будет объект, который конструктор создаёт:
```JavaScript
    function User() {
        console.log(this instanceof User); // true
        this.name = 'Alex'
    }

    const firstUser = new User();
    console.log(firstUser instanceof User); // true
```

Что происходит при вызове конструктора:
* При вызове сперва создаётся новый пустой объект, и он присваивается this.
* Выполняется код функции. (Обычно он модифицирует this, добавляет туда новые свойства.)
* Возвращается значение this.

### Вызов без объекта: this == undefined или window

Когда мы вызываем функцию, значением this может быть лишь глобальный объект или undefined при использовании 'use strict'.

```JavaScript
    'use strict';

    function sayHi() {
        console.log(this);
    }

    sayHi(); // undefined
```

### У стрелочных функций нет «this»

Стрелочные функции особенные: у них нет своего «собственного» this. Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.

Например, здесь arrow() использует значение this из внешнего метода user.sayHi():
```JavaScript
    let user = {
        firstName: "Dima",
        sayHi() {
            let arrow = () => alert(this.firstName);
            arrow();
        }
    };

    user.sayHi(); // Dima
```

### Итого

* Функции, которые находятся в свойствах объекта, называются «методами».
* Методы позволяют объектам «действовать»: object.doSomething().
* Методы могут ссылаться на объект через this.
* Значение this определяется во время исполнения кода.
* При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
* Функция может быть скопирована между объектами (из одного объекта в другой).
* Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.

## 3 what is Closure and how does it work?

## 4 var` vs `let` vs `const`

## 5 Explain the concept of Promise to a 5-year-old

