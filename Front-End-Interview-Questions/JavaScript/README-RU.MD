# Вопросы по JavaScript

## 1 Что такое прототипное наследование? Как оно работает?

Прототипное наследование - это наследование свойств и методов обьекта родителя путем присваивание его к скрытому свойству "Prototype" экземпляра обьекта;

Обьекты в JavaScript содержат скрытое свойство "Prototype", к каторому можно присвоить другой обьект;

При вызове свойства обьекта оно сначала ищется у него самого, а потом ищется у его родителей через цепочку прототипов, до того пока свойство не будет найдено или прототип не будет равен null, тогда вернется undefined.

Пример A:
```JavaScript
    const a = {
        name: "Dima"
    }

    const b = {}

    b.__proto__ = a;

    console.log(b.name); // Dima
```

Переопределение свойства родительского обьекта приводит к создании копии этого свойства в текущем обьекте.

Пример B:
```JavaScript
    // ... Пример A

    b.name = "Roma";

    console.log(b.name); // Roma
    console.log(b.__proto__.name); // Dima
```

При вызове родительского метода this, внутри него, указывает на текущий обьект: поиск свойства у this происходит через цепочку прототипов.

Пример C:
```JavaScript
    // ... Пример B

    a.sayHi = function() {
        return "Привет " + this.name + "!";
    }

    console.log(b.sayHi()); // Привет Roma!
    console.log(b.__proto__.sayHi()); //  Привет Dima!
```

Цепочка прототипов может быть длиннее:
```JavaScript
    const a = { name: "Dima" }
    const b = { age: 23, __proto__: a }
    const c = { hairColor: "Brown", __proto__: b }

    // name взят из цепочки прототипов
    console.log(c.name); // Dima
    console.log(b.age); // 23 (из обьекта b)
```

Операция записи не использует прототип - Прототип используется только для чтения свойств. Операции записи/удаления работают напрямую с объектом.

В приведённом ниже примере мы присваиваем rabbit собственный метод walk:
```JavaScript
    let animal = {
        eats: true,
        walk() {
            /* этот метод не будет использоваться в rabbit */
        }
    };

    let rabbit = {
        __proto__: animal
    };

    rabbit.walk = function() {
        alert("Кролик! Прыгает!");
    };

    rabbit.walk(); // Кролик! Прыгает!
```

Свойства-аксессоры – исключение, так как запись в него обрабатывается функцией-сеттером. То есть это фактически вызов функции.

По этой причине admin.fullName работает корректно в приведённом ниже коде:
```JavaScript
    let user = {
        name: "Dima",
        surname: "Chekashov",

        set fullName(value) {
            [this.name, this.surname] = value.split(" ");
        },

        get fullName() {
            return `${this.name} ${this.surname}`;
        }
    };

    let admin = {
        __proto__: user,
        isAdmin: true
    };

    alert(admin.fullName); // Dima Chekashov (*)

    // срабатывает сеттер!
    admin.fullName = "Roma Chekashov"; // (**)
    alert(admin.name); // Roma
    alert(admin.surname); // Chekashov
```
Здесь в строке (*) свойство admin.fullName имеет геттер в прототипе user, поэтому вызывается он. В строке (**) свойство также имеет сеттер в прототипе, который и будет вызван.

Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта.

Например:
```JavaScript
    let animal = {
        eats: true
    };

    let rabbit = {
        jumps: true,
        __proto__: animal
    };

    // Object.keys возвращает только собственные ключи
    alert(Object.keys(rabbit)); // jumps

    // for..in проходит и по своим, и по унаследованным ключам
    for(let prop in rabbit) alert(prop); // jumps, затем eats
```

Если унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с именем key.

#### Итого

* В JavaScript все объекты имеют скрытое свойство [[Prototype]], которое является либо другим объектом, либо null.
* Мы можем использовать obj.__proto__ для доступа к нему.
* Объект, на который ссылается [[Prototype]], называется «прототипом».
* Если мы хотим прочитать свойство obj или вызвать метод, которого не существует у obj, тогда JavaScript попытается найти его в прототипе.
* Операции записи/удаления работают непосредственно с объектом, они не используют прототип (если это обычное свойство, а не сеттер).
* Если мы вызываем obj.method(), а метод при этом взят из прототипа, то this всё равно ссылается на obj. Таким образом, методы всегда работают с текущим объектом, даже если они наследуются.
* Цикл for..in перебирает как свои, так и унаследованные свойства. Остальные методы получения ключей/значений работают только с собственными свойствами объекта.

## 2 Обьясните значение `this` в JavaScript

this - это ссылка на некий объект, к свойствам которого можно получить доступ внутри вызова функции. Этот this — и есть контекст выполнения.

```JavaScript
    let user = {
        name: "John",
        age: 30,

        sayHi() {
            // "this" - это "текущий объект".
            alert(this.name);
        }
    };

    user.sayHi(); // John
```

Значение this определяется во время выполнения кода, в зависимости от контекста. Если записать метод объекта в переменную и вызвать её, значение this изменится.

```JavaScript
    const user = {
        name: 'Alex',
        greet() {
            console.log(`Hello, my name is ${this.name}`)
        },
    }

    const greet = user.greet
    greet()
    // Hello, my name is
```

При вызове через точку user.greet() значение this равняется объекту до точки (user). Без этого объекта this равняется глобальному объекту. В строгом режиме мы бы получили ошибку «Cannot read properties of undefined».

Чтобы такого не происходило, следует использовать bind().

### Вызов конструктора

При вызове конструктора this равен свежесозданному объекту.

В примере с User значением this будет объект, который конструктор создаёт:
```JavaScript
    function User() {
        console.log(this instanceof User); // true
        this.name = 'Alex'
    }

    const firstUser = new User();
    console.log(firstUser instanceof User); // true
```

Что происходит при вызове конструктора:
* При вызове сперва создаётся новый пустой объект, и он присваивается this.
* Выполняется код функции. (Обычно он модифицирует this, добавляет туда новые свойства.)
* Возвращается значение this.

### Вызов без объекта: this == undefined или window

Когда мы вызываем функцию, значением this может быть лишь глобальный объект или undefined при использовании 'use strict'.

```JavaScript
    'use strict';

    function sayHi() {
        console.log(this);
    }

    sayHi(); // undefined
```

### У стрелочных функций нет «this»

Стрелочные функции особенные: у них нет своего «собственного» this. Если мы ссылаемся на this внутри такой функции, то оно берётся из внешней «нормальной» функции.

Например, здесь arrow() использует значение this из внешнего метода user.sayHi():
```JavaScript
    let user = {
        firstName: "Dima",
        sayHi() {
            let arrow = () => alert(this.firstName);
            arrow();
        }
    };

    user.sayHi(); // Dima
```

### Итого

* Функции, которые находятся в свойствах объекта, называются «методами».
* Методы позволяют объектам «действовать»: object.doSomething().
* Методы могут ссылаться на объект через this.
* Значение this определяется во время исполнения кода.
* При объявлении любой функции в ней можно использовать this, но этот this не имеет значения до тех пор, пока функция не будет вызвана.
* Функция может быть скопирована между объектами (из одного объекта в другой).
* Когда функция вызывается синтаксисом «метода» – object.method(), значением this во время вызова является object.

## 3 Что такое Замыкания и как они работают?

Замыкание – это функция, которая запоминает свои внешние переменные и может получить к ним доступ.

То есть они автоматически запоминают, где были созданы, с помощью скрытого свойства [[Environment]], и все они могут получить доступ к внешним переменным.

### Пояснение:

В JavaScript у каждой выполняемой функции, блока кода и скрипта есть связанный с ними внутренний (скрытый) объект, называемый лексическим окружением LexicalEnvironment.

Объект лексического окружения состоит из двух частей:
* Environment Record – объект, в котором как свойства хранятся все локальные переменные (а также некоторая другая информация, такая как значение this).
* Ссылка на внешнее лексическое окружение – то есть то, которое соответствует коду снаружи (снаружи от текущих фигурных скобок).

"Переменная" – это просто свойство специального внутреннего объекта: Environment Record. «Получить или изменить переменную», означает, «получить или изменить свойство этого объекта».

Например, в этом простом коде только одно лексическое окружение:
```JavaScript
    let hello = "Hello World!"; // Лексическое Окружение: hello: "Hello World!", ссылка на внешнее равно null

    alert(hello);
```

Это, так называемое, глобальное лексическое окружение, связанное со всем скриптом.

В коде выше переменная хранится в Environment Record (хранилище переменных), а ссылку на внешнее окружение равна null. У глобального лексического окружения нет внешнего окружения, так что она указывает на null.

При запуске функции для неё автоматически создаётся новое лексическое окружение, для хранения локальных переменных и параметров вызова.

Например, для say("Dima") это выглядит так:
```JavaScript
    const phrase = "Hello";

    function say(name) {
        console.log(`${phrase}, ${name}!`);
    }

    say("Dima"); // Hello, Dima!
```

Итак, в процессе вызова функции у нас есть два лексических окружения: внутреннее (для вызываемой функции) и внешнее (глобальное):

* Внутреннее лексическое окружение соответствует текущему выполнению say. В нём находится одна переменная name, аргумент функции. Мы вызываем say("Dima"), так что значение переменной name равно "Dima".
* Внешнее лексическое окружение – это глобальное лексическое окружение. В нём находятся переменная phrase и сама функция.

У внутреннего лексического окружения есть ссылка outer на внешнее.

Когда код хочет получить доступ к переменной – сначала происходит поиск во внутреннем лексическом окружении, затем во внешнем, затем в следующем и так далее, до глобального.

Если переменная не была найдена, это будет ошибкой в strict mode. Без strict mode, для обратной совместимости, присваивание несуществующей переменной создаёт новую глобальную переменную с таким именем.

#### Один вызов – одно лексическое окружение
Новое лексическое окружение функции создаётся каждый раз, когда функция выполняется.

#### Лексическое окружение – это специальный внутренний объект
«Лексическое окружение» – это специальный внутренний объект. Мы не можем получить его в нашем коде и изменять напрямую. Сам движок JavaScript может оптимизировать его, уничтожать неиспользуемые переменные для освобождения памяти и выполнять другие внутренние уловки, но видимое поведение объекта должно оставаться таким, как было описано.

Функция называется «вложенной», когда она создаётся внутри другой функции.

Например:
```JavaScript
    function makeCounter() {
        let count = 0;

        return function() {
            return count++; // есть доступ к внешней переменной "count"
        };
    }

    let counter = makeCounter();

    console.log( counter() ); // 0
    console.log( counter() ); // 1
    console.log( counter() ); // 2
```

Как же это работает изнутри?

Когда внутренняя функция начинает выполняться, начинается поиск переменной count++ изнутри-наружу. Для примера выше порядок будет такой:

1. Локальные переменные вложенной функции…
2. Переменные внешней функции…
3. И так далее, пока не будут достигнуты глобальные переменные.

В этом примере count будет найден на шаге 2. Когда внешняя переменная модифицируется, она изменится там, где была найдена. Значит, count++ найдёт внешнюю переменную и увеличит её значение в лексическом окружении, которому она принадлежит. Как если бы у нас было let count = 1.

Вот что происходит в примере с makeCounter шаг за шагом.

1. Когда скрипт только начинает выполняться, есть только глобальное лексическое окружение:
    * В этот начальный момент есть только функция makeCounter, потому что это Function Declaration. Она ещё не выполняется.
    * Все функции «при рождении» получают скрытое свойство [[Environment]], которое ссылается на лексическое окружение места, где они были созданы.
    * В данном случае, makeCounter создан в глобальном лексическом окружении, так что [[Environment]] содержит ссылку на него.
    * Другими словами, функция навсегда запоминает ссылку на лексическое окружение, где она была создана. И [[Environment]] – скрытое свойство функции, которое содержит эту ссылку.
2. Код продолжает выполняться, объявляется новая глобальная переменная counter, которой присваивается результат вызова makeCounter:
    * В момент вызова makeCounter() создаётся лексическое окружение, для хранения его переменных и аргументов.
    * Как и все лексические окружения, оно содержит две вещи:
        1. Environment Record с локальными переменными. В нашем случае count – единственная локальная переменная (появляющаяся, когда выполняется строчка с let count).
        2. Ссылка на внешнее окружение, которая устанавливается в значение [[Environment]] функции. В данном случае, [[Environment]] функции makeCounter ссылается на глобальное лексическое окружение.
    * Итак, теперь у нас есть два лексических окружения: первое – глобальное, второе – для текущего вызова makeCounter, с внешней ссылкой на глобальный объект.
3. В процессе выполнения makeCounter() создаётся небольшая вложенная функция.
    * Не имеет значения, какой способ объявления функции используется: Function Declaration или Function Expression. Все функции получают свойство [[Environment]], которое ссылается на лексическое окружение, в котором они были созданы. То же самое происходит и с нашей новой маленькой функцией.
    * Для нашей новой вложенной функции значением [[Environment]] будет текущее лексическое окружение makeCounter() (где она была создана):
4. Выполнение продолжается, вызов makeCounter() завершается, и результат (небольшая вложенная функция) присваивается глобальной переменной counter:
    * В этой функции есть только одна строчка: return count++, которая будет выполнена, когда мы вызовем функцию.
5. При вызове counter() для этого вызова создаётся новое лексическое окружение. Оно пустое, так как в самом counter локальных переменных нет. Но [[Environment]] counter используется, как ссылка на внешнее лексическое окружение outer, которое даёт доступ к переменным предшествующего вызова makeCounter, где counter был создан.
    * Теперь, когда вызов ищет переменную count, он сначала ищет в собственном лексическом окружении (пустое), а затем в лексическом окружении предшествующего вызова makeCounter(), где и находит её.
    * Пожалуйста, обратите внимание, как здесь работает управление памятью. Хотя makeCounter() закончил выполнение некоторое время назад, его лексическое окружение остаётся в памяти, потому что есть вложенная функция с [[Environment]], который ссылается на него.
    * В большинстве случаев, объект лексического окружения существует до того момента, пока есть функция, которая может его использовать. И только тогда, когда таких не остаётся, окружение уничтожается.
6. Вызов counter() не только возвращает значение count, но также увеличивает его. Обратите внимание, что модификация происходит «на месте». Значение count изменяется конкретно в том окружении, где оно было найдено.
7. Следующие вызовы counter() сделают то же самое.

### Сборка мусора

Обычно лексическое окружение очищается и удаляется после того, как функция выполнилась. Например:
```JavaScript
    function f() {
        let value1 = 123;
        let value2 = 456;
    }

    f();
```

Здесь два значения, которые технически являются свойствами лексического окружения. Но после того, как f() завершится, это лексическое окружение станет недоступно, поэтому оно удалится из памяти.

…Но, если есть вложенная функция, которая всё ещё доступна после выполнения f, то у неё есть свойство [[Environment]], которое ссылается на внешнее лексическое окружение, тем самым оставляя его достижимым, «живым»:
```JavaScript
    function f() {
        let value = 123;

        function g() { alert(value); }

        return g;
    }

    let g = f(); // g доступно и продолжает держать внешнее лексическое окружение в памяти
```

Объект лексического окружения умирает, когда становится недоступным (как и любой другой объект). Другими словами, он существует только до того момента, пока есть хотя бы одна вложенная функция, которая ссылается на него.

В следующем коде, после того как g станет недоступным, лексическое окружение функции (и, соответственно, value) будет удалено из памяти:
```JavaScript
    function f() {
        let value = 123;

        function g() { alert(value); }

        return g;
    }

    let g = f(); // пока g существует,
    // соответствующее лексическое окружение существует

    g = null; // ...а теперь память очищается
```

## 4 var` vs `let` vs `const`

### var

Объявление переменных при помощи ключевого слова var было в JavaScript с первых версий.

Переменные, объявленные через var, имеют функциональную область видимости. Они доступны только в пределах текущей функции или глобального объекта, если функции нет.

Объявление переменных вне функций делает их глобальными переменными. Они доступны как свойства глобального объекта.

К переменным, объявленным при помощи ключевого слова var, можно обращаться до момента объявления. В отличие от let и const, ошибки это не вызовет. Такое поведение называется hoisting - «всплытие».

Значение, хранящееся в переменной var, можно изменить двумя способами:
* обратиться к имени переменной и присвоить новое значение:
* обратиться к имени переменной вместе с ключевым словом var:

### let and const

Значение в переменной, созданной через let, можно изменять.

Стартовое значение const изменить нельзя, будь то примитивное значение.

К переменным let и const нельзя обращаться до их объявления в коде.

При помощи const нельзя объявлять переменные без значения.

У let и const есть так называемая temporal dead zone (TDZ) — момент выполнения скрипта до объявления переменной. Переменная может использоваться и выше объявления, при условии, что содержащая её часть кода будет выполнена после инициализации:

Оба типа переменных имеют блочную область видимости и не становятся частью глобального объекта (window в браузере, global в Node.js). Блочная область видимости не даёт получить значение переменной вне блока, где она была объявлена.

В то же время можно объявлять переменные с одинаковым именем в разных областях видимости. В этом случае значение будет зависеть от той области видимости, где происходит чтение.

Однако объект, хранящийся в const, можно мутировать. Объекты хранятся по ссылке, и изменение объекта не приводит к изменению ссылки на него.

## 5 Обьясните что такое Promise

Promise - это спецальный обьект JavaScript, каторый служит для работы с асинхроным кодом.

Внутри промиса работает асинхронная операция, которая управляет его состоянием.

Промис может находиться в одном из трёх состояний:

- pending — стартовое состояние, операция стартовала;
- fulfilled — получен результат;
- rejected — ошибка.

Промис создается с помощью конструктора.

В конструктор передаётся функция-исполнитель асинхронной операции (англ. executor). Она вызывается сразу после создания промиса. Задача этой функции — выполнить асинхронную операцию и перевести состояние промиса в fulfilled (успех) или rejected (ошибка).

Изменить состояние промиса можно, вызвав колбэки, переданные аргументами в функцию:

```JavaScript
    // Вызов resolved переведет промис в состояние fulfilled, а reject в rejected
    const promise = new Promise((resolve, reject) => {
        const data = "..."; // Асинхронная операция: запрос к бд, api
        resolve(data); // Переводим промис в соостаяние fulfilled и отдаем наружу результат операции
    })
```

```JavaScript
    const promise = new Promise(function (resolve, reject) {
        // делаем асинхронную операцию
        const data = resolve(data) // запрос в БД, API, etc. // переводим промис в состояние fulfilled и отдаём наружу результат операции
    })

    const errorPromise = new Promise(function (resolve, reject) {
        reject(new Error('ошибка')) // переводим промис в состояние rejected и отдаём наружу ошибку
    })
```

* первый параметр (в примере кода назван resolve) — колбэк для перевода промиса в состояние fulfilled, при его вызове аргументом передаётся результат операции;
* второй параметр (в примере кода назван reject) — колбэк для перевода промиса в состояние rejected, при его вызове аргументом передаётся информация об ошибке.

### Как понять Promise

Промис решает задачу выполнения кода, который зависит от результата асинхронной операции.

Промис устроен таким образом, что рычаги управления его состоянием остаются у асинхронной функции. После создания, промис находится в состоянии ожидания pending. Когда асинхронная операция завершается, функция переводит промис в состояние успеха fulfilled или ошибки rejected.

С помощью методов then(), catch() и finally() мы можем реагировать на изменение состояния промиса и выполнять код.

### Методы Promise

Метод then() используют, чтобы выполнить код после успешного выполнения асинхронной операции. Он принимает в качестве аргумента функцию-колбэк, которая выполняется сразу после того, как промис поменял состояние на fulfilled. Параметр колбэка содержит результат выполнения операции:

```JavaScript
    fetch(`https://swapi.dev/api/films/${id}/`)
        .then(function (movies) {
            renderList(movies)
        });
```

Метод catch() используют, чтобы выполнить код в случае ошибки при выполнении асинхронной операции. Он принимает в качестве аргумента функцию-колбэк, которая выполняется сразу после того, как промис поменял состояние на rejected. Параметр колбэка содержит экземпляр ошибки:

```JavaScript
    fetch(`https://swapi.dev/api/films/${id}/`)
        .catch(function (error) {
            renderErrorMessage(error)
        })
```

Метод finally() используют, чтобы выполнить код при завершении асинхронной операции. Он будет выполнен вне зависимости от того, была ли операция успешной или завершилась ошибкой. Он принимает в качестве аргумента функцию-колбэк, которая выполняется сразу после того, как промис поменял состояние на rejected или fulfilled.

К примеру самый частый сценарий использования finally() — работа с индикаторами загрузки. Перед началом асинхронной операции разработчик включает индикатор загрузки. Индикатор нужно убрать вне зависимости от того, как завершилась операция. Если этого не сделать, то пользователь не сможет взаимодействовать с интерфейсом:

```JavaScript
    let isLoading = true;

    fetch(`https://swapi.dev/api/films/${id}/`)
        .finally(function () {
            isLoading = false;
        })
```

### Цепочки методов Promise

Методы then(), catch() и finally() часто объединяют в цепочки вызовов, чтобы обработать и успешный, и ошибочный сценарии:

```JavaScript
    let isLoading = true;

    fetch(`https://swapi.dev/api/films/${id}/`)
        .then(function (movies) {
            renderList(movies)
        })
        .catch(function (err) {
            renderErrorMessage(err)
        })
        .finally(function () {
            isLoading = false
        })
```

В этом случае при успешном завершении операции мы выполним код из then(), при ошибке — код из catch(). Затем выполнится код из finally().

Цепочки методов — очень гибкий подход. Он позволяет создавать зависимые асинхронные операции.

Например, нужно отобразить информацию о фильме и главном герое. Мы не знаем, кто главный герой, не получив эту информацию из данных о фильме. Таким образом, запрос данных о герое зависит от результата запроса данных о фильме.

Промисы делают решение простым и читаемым. Мы можем начинать следующее асинхронное действие внутри колбэка метода then(). Все, что возвращается из колбэка, оборачивается в промис, поэтому в цепочку можно добавить новый then():

```JavaScript
    fetch(`https://swapi.dev/api/films/${id}/`)
        .then(function (response) {
            // этот then сработает, когда разрешится промис с запросом данных о фильме
            return response.json() // нужно распарсить ответ сервера, это асинхронная операция
        })
        .then(function (movie) {
            // этот then сработает, когда данные о фильме распарсятся
            const characterUrl = movie.characters[0]
            return fetch(characterUrl) // вызов fetch вернет промис, возвращаем его из колбэка, чтобы продолжить цепочку
        })
        .then(function (response) {
            // этот then сработает, когда разрешится промис с результатами запроса персонажа
            return response.json()
        })
        .then(function (character) {
            renderCharacterProfile(character)
        })
        .catch(function (err) {
            // catch сработает, когда любая из операций выше завершится ошибкой
            renderErrorMessage(err)
        })
```