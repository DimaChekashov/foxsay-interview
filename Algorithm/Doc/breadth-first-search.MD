## Поиск в ширину
Поиск в ширину позволяет найти кратчайшее расстояние между двумя объ­ектами. Однако сам термин «кратчайшее расстояние» может иметь много разных значений! Например, с помощью поиска в ширину можно:
* написать программу для игры в шашки, которая вычисляет кратчайший путь к победе;
* реализовать проверку правописания (минимальное количество измене­ний, преобразующих ошибочно написанное слово в правильное, напри­мер АЛГОРИФМ -> АЛГОРИТМ - одно изменение);
* найти ближайшего к вам врача.

### Знакомство с графами
Предположим, вы находитесь в Сан-Франциско и хотите добраться из Твин-Пике к мосту Золотые Ворота. Вы намереваетесь доехать на автобусе с минимальным количеством пересадок.
Можно ли сделать это за один шаг?
Из двух доступных путей мост еще выделен; до него невозможно добраться за один шаг. А можно ли добраться до него за два шага?
И снова мост не выделен, а значит, до него невозможно добраться за два шага. Как насчет трех шагов?
Ага! На этот раз мост Золотые Ворота выделен. Следовательно, чтобы до­ браться из Твин-Пике к мосту по этому маршруту, необходимо сделать три шага.

Есть и другие маршруты, которые приведут вас к мосту, но они длиннее (четыре шага). Алгоритм обнаружил, что кратчайший путь к мосту состоит из трех шагов. Задача такого типа называется **задачей поиска кратчайшего пути**. Часто требуется найти некий кратчайший путь: путь к дому вашего друга, путь к победе в шахматной партии (за наименьшее количество ходов) и т. д. Алгоритм для решения задачи поиска кратчайшего пути называется **поиском в ширину**.

Чтобы найти кратчайший путь из Твин-Пике к мосту Золотые Ворота, нам пришлось выполнить два шага:
* Смоделировать задачу в виде графа.
* Решить задачу методом поиска в ширину.

### Что такое граф?
Граф моделирует набор связей. Пред­ ставьте, что вы с друзьями играете в по­кер и хотите смоделировать, кто кому сейчас должен. Например, условие «Алекс должен Раме» можно смодели­ ровать так:
**Алекс ----> Рама**
А полный граф может выглядеть так:
**Алекс ----> Рама ----> Адит ----> Том ----> Рама**
Алекс должен Раме, Том должен Адиту и т. д. Каждый граф состоит из **узлов** и **ребер**.

Вот и все! Графы состоят из узлов и ребер. Узел может быть напрямую со­единен с несколькими другими узлами. Эти узлы называются **соседями**. На этом графе Рама является соседом Алекса. С другой стороны, Адит соседом Алекса не является, потому что они не соединены напрямую. Приэтом Адит является соседом Рамы и Тома.

Графы используются для моделирования связей между разными объектами.

### Поиск в ширину
В самом начале уже рассматривался пример алгоритма поиска: бинарный по­иск. Поиск в ширину также относится к категории алгоритмов поиска, но этот алгоритм работает с графами. Он помогает ответить на вопросы двух типов:
* тип 1: существует ли путь от узла А к узлу В?
* тип 2: как выглядит кратчайший путь от узла А к узлу В?

Вы уже видели пример поиска в ширину, когда мы просчитывали кратчай­ший путь из Твин-Пике к мосту Золотые Ворота. Это был вопрос типа 2: как выглядит кратчайший путь? Теперь разберем работу алгоритма более подробно с вопросом типа 1: существует ли путь?

Представьте, что вы выращиваете манго. Вы ищете продавца, который будет продавать ваши замечательные манго. А может, продавец найдется среди ваших контактов на Facebook? Для начала стоит поискать среди друзей.

Поиск происходит вполне тривиально.
Сначала нужно построить список друзей для поиска.
Теперь нужно обратиться к каждому человеку в списке и проверить, продает ли этот человек манго.

Предположим, ни один из ваших друзей не продает манго. Теперь поиск продолжается среди друзей ваших друзей.

Каждый раз, когда вы проверяете кого-то из списка, вы добавляете в список всех его друзей.

В таком случае поиск ведется не только среди друзей, но и среди друзей друзей тоже. Напомним: нужно найти в сети хотя бы одного продавца ман­го. Если Алиса не продает манго, то в список добавляются ее друзья. Это означает, что со временем вы проверите всех ее друзей, а потом их друзей и т. д. С этим алгоритмом поиск рано или поздно пройдет по всей сети, пока вы все-таки не наткнетесь на продавца манго. Такой алгоритм и называется поиском в ширину.

### Поиск кратчайшего пути
На всякий случай напомню два вопроса, на которые может ответить алго­ритм поиска в ширину:
* тип 1: существует ли путь от узла А к узлу В? (Есть ли продавец манго в вашей сети?)
* тип 2: как выглядит кратчайший путь от узла А к узлу В? (Кто из про­давцов манго находится ближе всего к вам?)

Вы уже знаете, как ответить на вопрос 1; теперь попробуем ответить на вопрос 2. Удастся ли вам найти ближайшего продавца манго? Будем счи­тать, что ваши друзья - это связи первого уровня, а друзья друзей - связи второго уровня.

Связи первого уровня предпочтительнее связей второго уровня, связи второго уровня предпочтительнее связей третьего уровня и т. д. Отсюда следует, что поиск по контактам второго уровня не должен производить­ся, пока вы не будете полностью уверены в том, что среди связей первого уровня нет ни одного продавца манго. Но ведь поиск в ширину именно это и делает! Поиск в ширину распространяется от начальной точки. А это оз­начает, что связи первого уровня будут проверены до связей второго уровня. Контрольный вопрос: кто будет проверен первым, Клэр или Анудж? Ответ:
Клэр является связью первого уровня, а Анудж - связью второго уровня. Следовательно, Клэр будет проверена первой.

Также можно объяснить это иначе: связи первого уровня добавляются в список поиска раньше связей второго уровня.

Вы двигаетесь вниз по списку и проверяете каждого человека (является ли он продавцом манго). Связи первого уровня будут проверены до связей второго уровня, так что вы найдете продавца манго, ближай­шего к вам. Поиск в ширину находит не только путь из А в В, но и кратчайший путь.

Обратите внимание: это условие выполняется только в том случае, если поиск осуществляется в порядке добавления людей. Другими словами, если Клэр была
добавлена в список до Ануджа, то проверка Клэр должна быть выполнена до проверки Ануджа. А что произойдет, если вы проверите Ануджа раньше, чем Клэр, и оба они окажутся продавцами манго? Анудж является связью второгоуровня, а Клэр - связью первого уровня. В результате будет найден продавец манго, не ближайший к вам в сети. Следовательно, проверять свя­зи нужно в порядке их добавления. Для операций такого рода существует специальная структура данных, которая называется **очередью**.

### Очереди
Очередь работает точно так же, как и в реальной жизни. Предполо­жим, вы с другом стоите в очереди на автобусной остановке. Если вы стоите ближе к началу очереди, то вы первым сядете в автобус. Струк­тура данных очереди работает ана­логично. Очереди чем-то похожи на стеки: вы не можете обращаться к произвольным элементам очере­ди. Вместо этого поддерживаются всего две операции: **постановка в очередь** и **извлечение из очереди**.

Если вы поставите в очередь два элемента, то элемент, добавленный пер­вым, будет извлечен из очереди раньше второго. А ведь это свойство можно использовать для реализации списка поиска! Люди, добавленные в список первыми, будут извлечены из очереди и проверены первыми.

Очередь относится к категории структур данных **FIFO: First In, First Out** («первым вошел, первым вышел»). А стек принадлежит к числу структур данных **LIFO: Last In, First Out** («последним пришел, первым вышел»).

Теперь, когда вы знаете, как работает очередь, можно переходить к реали­зации поиска в ширину!

### Реализация графа
Для начала необходимо реализовать граф на программном уровне. Граф состоит из нескольких узлов. И каждый узел соединя­ется с соседними узлами. Как выразить от­ношение типа «вы -> боб»? К счастью, вам уже известна структура данных, способная выражать отношения: хеш-таблица!

Вспомните: хеш-таблица связывает ключ со значением. В данном случае узел должен быть связан со всеми его соседями.
```JavaScript
let graph = new Map();
graph.set("you", ["alice", "bob", "claire"]);
```
Обратите внимание: элемент **вы** (you) отображается на массив. Следова­тельно, результатом выражения graph.get("you") является массив всех ваших соседей.

Граф - всего лишь набор узлов и ребер, поэтому для представления графа на Python ничего больше не потребуется. А как насчет большего графа?
```JavaScript
let graph = new Map();
graph.set("you", ["alice", "bob", "claire"]);
graph.set("alice", ["peggy"]);
graph.set("bob", ["anuj", "peggy"]);
graph.set("claire", ["thom", "jonny"]);
graph.set("anuj", []);
graph.set("peggy", []);
graph.set("thom", []);
graph.set("jonny", []);
```

Контрольный вопрос: важен ли порядок добавления пар **ключ-зна­чение**?
Важно ли, какую запись вы будете использовать, - такую:
```JavaScript
graph.set("claire", ["thom", "jonny"]);
graph.set("anuj", []);
```
или такую:
```JavaScript
graph.set("anuj", []);
graph.set("claire", ["thom", "jonny"]);
```
Ответ: нет, не важно. В хеш-таблицах эле­менты не упорядочены, поэтому добавлять пары **ключ-значение** можно в любом порядке.

У Ануджа, Пегги, Тома и Джонни соседей нет. Линии со стрелками ука­зывают на них, но не существует стрелок от них к другим узлам. Такой граф называется направленным - отношения действуют только в одну сторону. Итак, Анудж является соседом Боба, но Боб не является соседом Ануджа. В ненаправленном графе стрелок нет, и каждый из узлов являет­ся соседом по отношению друг к другу. Например, оба следующих графа эквивалентны.
* Направленный граф: РОСС <--> РЭЙЧЕЛ
* Ненаправленный граф: РОСС --- РЭЙЧЕЛ

