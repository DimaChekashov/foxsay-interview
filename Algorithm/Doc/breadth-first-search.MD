## Поиск в ширину
Поиск в ширину позволяет найти кратчайшее расстояние между двумя объ­ектами. Однако сам термин «кратчайшее расстояние» может иметь много разных значений! Например, с помощью поиска в ширину можно:
* написать программу для игры в шашки, которая вычисляет кратчайший путь к победе;
* реализовать проверку правописания (минимальное количество измене­ний, преобразующих ошибочно написанное слово в правильное, напри­мер АЛГОРИФМ -> АЛГОРИТМ - одно изменение);
* найти ближайшего к вам врача.

### Знакомство с графами
Предположим, вы находитесь в Сан-Франциско и хотите добраться из Твин-Пике к мосту Золотые Ворота. Вы намереваетесь доехать на автобусе с минимальным количеством пересадок.
Можно ли сделать это за один шаг?
Из двух доступных путей мост еще выделен; до него невозможно добраться за один шаг. А можно ли добраться до него за два шага?
И снова мост не выделен, а значит, до него невозможно добраться за два шага. Как насчет трех шагов?
Ага! На этот раз мост Золотые Ворота выделен. Следовательно, чтобы до­ браться из Твин-Пике к мосту по этому маршруту, необходимо сделать три шага.

Есть и другие маршруты, которые приведут вас к мосту, но они длиннее (четыре шага). Алгоритм обнаружил, что кратчайший путь к мосту состоит из трех шагов. Задача такого типа называется **задачей поиска кратчайшего пути**. Часто требуется найти некий кратчайший путь: путь к дому вашего друга, путь к победе в шахматной партии (за наименьшее количество ходов) и т. д. Алгоритм для решения задачи поиска кратчайшего пути называется **поиском в ширину**.

Чтобы найти кратчайший путь из Твин-Пике к мосту Золотые Ворота, нам пришлось выполнить два шага:
* Смоделировать задачу в виде графа.
* Решить задачу методом поиска в ширину.

### Что такое граф?
Граф моделирует набор связей. Пред­ ставьте, что вы с друзьями играете в по­кер и хотите смоделировать, кто кому сейчас должен. Например, условие «Алекс должен Раме» можно смодели­ ровать так:
**Алекс ----> Рама**
А полный граф может выглядеть так:
**Алекс ----> Рама ----> Адит ----> Том ----> Рама**
Алекс должен Раме, Том должен Адиту и т. д. Каждый граф состоит из **узлов** и **ребер**.

Вот и все! Графы состоят из узлов и ребер. Узел может быть напрямую со­единен с несколькими другими узлами. Эти узлы называются **соседями**. На этом графе Рама является соседом Алекса. С другой стороны, Адит соседом Алекса не является, потому что они не соединены напрямую. Приэтом Адит является соседом Рамы и Тома.

Графы используются для моделирования связей между разными объектами.

### Поиск в ширину
В самом начале уже рассматривался пример алгоритма поиска: бинарный по­иск. Поиск в ширину также относится к категории алгоритмов поиска, но этот алгоритм работает с графами. Он помогает ответить на вопросы двух типов:
* тип 1: существует ли путь от узла А к узлу В?
* тип 2: как выглядит кратчайший путь от узла А к узлу В?

Вы уже видели пример поиска в ширину, когда мы просчитывали кратчай­ший путь из Твин-Пике к мосту Золотые Ворота. Это был вопрос типа 2: как выглядит кратчайший путь? Теперь разберем работу алгоритма более подробно с вопросом типа 1: существует ли путь?

Представьте, что вы выращиваете манго. Вы ищете продавца, который будет продавать ваши замечательные манго. А может, продавец найдется среди ваших контактов на Facebook? Для начала стоит поискать среди друзей.

Поиск происходит вполне тривиально.
Сначала нужно построить список друзей для поиска.
Теперь нужно обратиться к каждому человеку в списке и проверить, продает ли этот человек манго.

Предположим, ни один из ваших друзей не продает манго. Теперь поиск продолжается среди друзей ваших друзей.

Каждый раз, когда вы проверяете кого-то из списка, вы добавляете в список всех его друзей.

В таком случае поиск ведется не только среди друзей, но и среди друзей друзей тоже. Напомним: нужно найти в сети хотя бы одного продавца ман­го. Если Алиса не продает манго, то в список добавляются ее друзья. Это означает, что со временем вы проверите всех ее друзей, а потом их друзей и т. д. С этим алгоритмом поиск рано или поздно пройдет по всей сети, пока вы все-таки не наткнетесь на продавца манго. Такой алгоритм и называется поиском в ширину.

### Поиск кратчайшего пути
На всякий случай напомню два вопроса, на которые может ответить алго­ритм поиска в ширину:
* тип 1: существует ли путь от узла А к узлу В? (Есть ли продавец манго в вашей сети?)
* тип 2: как выглядит кратчайший путь от узла А к узлу В? (Кто из про­давцов манго находится ближе всего к вам?)

Вы уже знаете, как ответить на вопрос 1; теперь попробуем ответить на вопрос 2. Удастся ли вам найти ближайшего продавца манго? Будем счи­тать, что ваши друзья - это связи первого уровня, а друзья друзей - связи второго уровня.

Связи первого уровня предпочтительнее связей второго уровня, связи второго уровня предпочтительнее связей третьего уровня и т. д. Отсюда следует, что поиск по контактам второго уровня не должен производить­ся, пока вы не будете полностью уверены в том, что среди связей первого уровня нет ни одного продавца манго. Но ведь поиск в ширину именно это и делает! Поиск в ширину распространяется от начальной точки. А это оз­начает, что связи первого уровня будут проверены до связей второго уровня. Контрольный вопрос: кто будет проверен первым, Клэр или Анудж? Ответ:
Клэр является связью первого уровня, а Анудж - связью второго уровня. Следовательно, Клэр будет проверена первой.

Также можно объяснить это иначе: связи первого уровня добавляются в список поиска раньше связей второго уровня.

Вы двигаетесь вниз по списку и проверяете каждого человека (является ли он продавцом манго). Связи первого уровня будут проверены до связей второго уровня, так что вы найдете продавца манго, ближай­шего к вам. Поиск в ширину находит не только путь из А в В, но и кратчайший путь.

Обратите внимание: это условие выполняется только в том случае, если поиск осуществляется в порядке добавления людей. Другими словами, если Клэр была
добавлена в список до Ануджа, то проверка Клэр должна быть выполнена до проверки Ануджа. А что произойдет, если вы проверите Ануджа раньше, чем Клэр, и оба они окажутся продавцами манго? Анудж является связью второгоуровня, а Клэр - связью первого уровня. В результате будет найден продавец манго, не ближайший к вам в сети. Следовательно, проверять свя­зи нужно в порядке их добавления. Для операций такого рода существует специальная структура данных, которая называется **очередью**.

### Очереди
Очередь работает точно так же, как и в реальной жизни. Предполо­жим, вы с другом стоите в очереди на автобусной остановке. Если вы стоите ближе к началу очереди, то вы первым сядете в автобус. Струк­тура данных очереди работает ана­логично. Очереди чем-то похожи на стеки: вы не можете обращаться к произвольным элементам очере­ди. Вместо этого поддерживаются всего две операции: **постановка в очередь** и **извлечение из очереди**.

Если вы поставите в очередь два элемента, то элемент, добавленный пер­вым, будет извлечен из очереди раньше второго. А ведь это свойство можно использовать для реализации списка поиска! Люди, добавленные в список первыми, будут извлечены из очереди и проверены первыми.

Очередь относится к категории структур данных **FIFO: First In, First Out** («первым вошел, первым вышел»). А стек принадлежит к числу структур данных **LIFO: Last In, First Out** («последним пришел, первым вышел»).

Теперь, когда вы знаете, как работает очередь, можно переходить к реали­зации поиска в ширину!

### Реализация графа
Для начала необходимо реализовать граф на программном уровне. Граф состоит из нескольких узлов. И каждый узел соединя­ется с соседними узлами. Как выразить от­ношение типа «вы -> боб»? К счастью, вам уже известна структура данных, способная выражать отношения: хеш-таблица!

Вспомните: хеш-таблица связывает ключ со значением. В данном случае узел должен быть связан со всеми его соседями.
```JavaScript
let graph = new Map();
graph.set("you", ["alice", "bob", "claire"]);
```
Обратите внимание: элемент **вы** (you) отображается на массив. Следова­тельно, результатом выражения graph.get("you") является массив всех ваших соседей.

Граф - всего лишь набор узлов и ребер, поэтому для представления графа на Python ничего больше не потребуется. А как насчет большего графа?
```JavaScript
let graph = new Map();
graph.set("you", ["alice", "bob", "claire"]);
graph.set("alice", ["peggy"]);
graph.set("bob", ["anuj", "peggy"]);
graph.set("claire", ["thom", "jonny"]);
graph.set("anuj", []);
graph.set("peggy", []);
graph.set("thom", []);
graph.set("jonny", []);
```

Контрольный вопрос: важен ли порядок добавления пар **ключ-зна­чение**?
Важно ли, какую запись вы будете использовать, - такую:
```JavaScript
graph.set("claire", ["thom", "jonny"]);
graph.set("anuj", []);
```
или такую:
```JavaScript
graph.set("anuj", []);
graph.set("claire", ["thom", "jonny"]);
```
Ответ: нет, не важно. В хеш-таблицах эле­менты не упорядочены, поэтому добавлять пары **ключ-значение** можно в любом порядке.

У Ануджа, Пегги, Тома и Джонни соседей нет. Линии со стрелками ука­зывают на них, но не существует стрелок от них к другим узлам. Такой граф называется направленным - отношения действуют только в одну сторону. Итак, Анудж является соседом Боба, но Боб не является соседом Ануджа. В ненаправленном графе стрелок нет, и каждый из узлов являет­ся соседом по отношению друг к другу. Например, оба следующих графа эквивалентны.
* Направленный граф: РОСС <--> РЭЙЧЕЛ
* Ненаправленный граф: РОСС --- РЭЙЧЕЛ

### Реализация алгоритма
Напомню, как работает реализация:
1. Создается очередь с именами проверяемых людей
2. Извлечение из очереди очередного человека
3. Проверить, являет­ся ли этот человек продавцом манго
4. Если да "завершить" иначе "добавить всех соседей этого человека в очередь"
5. Возврат на второе действие
6. Если очередь пуста, в вашей сети нет продавцов манго

Все начинается с создания очереди. В Python для создания двусторонней очереди (дека) используется функция deque:
```JavaScript
class Deque {
    constructor() {
        this.front = this.back = undefined;
    }
    addFront(value) {
        if (!this.front) this.front = this.back = { value };
        else this.front = this.front.next = { value, prev: this.front };
    }
    removeFront() {
        let value = this.peekFront();
        if (this.front === this.back) this.front = this.back = undefined;
        else (this.front = this.front.prev).next = undefined;
        return value;
    }
    peekFront() { 
        return this.front && this.front.value;
    }
    addBack(value) {
        if (!this.front) this.front = this.back = { value };
        else this.back = this.back.prev = { value, next: this.back };
    }
    removeBack() {
        let value = this.peekBack();
        if (this.front === this.back) this.front = this.back = undefined;
        else (this.back = this.back.next).back = undefined;
        return value;
    }
    peekBack() { 
        return this.back && this.back.value;
    }
}

let search_queue = new Deque();
search_queue.addFront(graph.get("you"));
```
Напомню, что выражение graph ["you"] вернет список всех ваших соседей, например ["alice", "ЬоЬ", "claire"]. Все они добавляются в очередь по­иска.

А теперь рассмотрим остальное:
```JavaScript
while (search_queue) {
    let person = search_queue.removeFront();

    if(person_is_seller(person)) {
        console.log(person + " is a mango seller!");
        return true;
    } else {
        search_queue.addFront(graph.person);
    }

    return false;
}
```
И последнее: нужно определить функцию person_is_seller, которая со­общает, является ли человек продавцом манго. Например, функция может выглядеть так:
```JavaScript
function person_is_seller(name) {
    return name[1] === "h";
}
Проверка довольно глупая, но для нашего примера сойдет.

Алгоритм продолжает работать до тех пор, пока:
* не будет найден продавец манго,
или
* очередь не опустеет (в этом случае продавца манго нет).
```
У Алисы и Боба есть один общий друг: Пегги. Следовательно, Пегги будет добавлена в очередь дважды: при добавлении друзей Алисы и при добав­лении друзей Боба. В результате Пегги появится в очереди поиска в двух экземплярах.

Но проверить, является ли Пегги продавцом манго, достаточно всего один раз. Проверяя ее дважды, вы выполняете лишнюю, ненужную работу. Сле­довательно, после проверки человека нужно пометить как проверенного, чтобы не проверять его снова.
В начале Очередь поиска содержит всех ваших соседей.
Теперь вы проверяете Пегги. Она не является продавцом манго, поэтому все ее соседи добавляются в очередь поиска.
Вы проверяете себя. Вы не являетесь продавцом манго, поэтому все ваши соседи добавляются в очередь поиска.
И так далее. Возникает бесконечный цикл, потому что очередь поиска будет поочередно переходить от вас к Пегги.
Прежде чем проверять человека, следует убедиться в том, что он не был проверен ранее. Для этого мы будем вести список уже проверенных людей.

А вот окончательная версия кода поиска в ширину, в которой учтено это обстоятельство:
```JavaScript
class Deque {
    constructor() {
        this.front = this.back = undefined;
    }
    addFront(value) {
        if (!this.front) this.front = this.back = { value };
        else this.front = this.front.next = { value, prev: this.front };
    }
    removeFront() {
        let value = this.peekFront();
        if (this.front === this.back) this.front = this.back = undefined;
        else (this.front = this.front.prev).next = undefined;
        return value;
    }
    peekFront() { 
        return this.front && this.front.value;
    }
    addBack(value) {
        if (!this.front) this.front = this.back = { value };
        else this.back = this.back.prev = { value, next: this.back };
    }
    removeBack() {
        let value = this.peekBack();
        if (this.front === this.back) this.front = this.back = undefined;
        else (this.back = this.back.next).back = undefined;
        return value;
    }
    peekBack() { 
        return this.back && this.back.value;
    }
}

function person_is_seller(name) {
    return name[1] === "h";
}

function search(name) {
    let search_queue = new Deque();
    search_queue.addFront(graph.get(name));
    let searched = new Map();

    while (search_queue) {
        let person = search_queue.removeFront();

        if(!searched.has(person)) {
            if(person_is_seller(person)) {
                console.log(person + " is a mango seller!");
                return true;
            } else {
                search_queue.addFront(graph.person);
                searched.add(person, true);
            }
        }

        return false;
    }
}

search("you");
```

### Время выполнения
Если поиск продавца манго был выполнен по всей сети, значит, вы прошли по каждому ребру (напомню: ребром называется соединительная линия или линия со стрелкой, ведущая от одного человека к другому). Таким образом, время выполнения составляет как минимум О(количество ребер).

Также в программе должна храниться очередь поиска. Добавление одно­го человека в очередь выполняется за постоянное время: О(1). Выпол­нение операции для каждого человека потребует суммарного времени О(количество людей). Поиск в ширину выполняется за время О(количество людей + количество ребер), что обычно записывается в форме O(V+E) ( V - количество вершин, Е - количество ребер).

### Шпаргалка
* Поиск в ширину позволяет определить, существует ли путь из А в В.
* Если путь существует, то поиск в ширину находит кратчайший путь.
* Если в вашей задаче требуется найти «кратчайшее Х», попробуйте смо­делировать свою задачу графом и воспользуйтесь поиском в ширину для ее решения.
* В направленном графе есть стрелки, а отношения действуют в направле­ нии стрелки (Рама -> Адит означает «Рама должен Адиту»).
* В ненаправленных графах стрелок нет, а отношение идет в обе стороны (Росс - Рэйчел означает «Росс встречается с Рэйчел, а Рэйчел встреча­ется с Россом».)
* Очереди относятся к категории FIFO («первым вошел, первым вышел»).
* Стек относится к категории LIFO («последним пришел, первым вышел»).
* Людей следует проверять в порядке их добавления в список поиска, поэтому список поиска должен быть оформлен в виде очереди, иначе найденный путь не будет кратчайшим.
* Позаботьтесь о том, чтобы уже прове­ренный человек не проверялся заново, иначе может возникнуть бесконечный цикл.
