## Рекурсия
Рекурсией называется вызов функцией самой себя.
Рекурсия применяется тогда, когда решение становится более понятным. Применение рекурсии не ускоряет работу программы: более того, решение с циклами иногда работает быстрее. 

**Ци­тата Ли Колдуэлла с сайта Stack Overlow**
*Циклы могут ускорить работу программы. Рекурсия может ускорить работу программиста. Выбирайте, что важнее в вашей ситуации!*

###  Базовый случай и рекурсивныи случай
Так как рекурсивная функция вызывает сама себя, программисту легко ошибиться и написать функцию так, что возникнет бесконечный цикл. Пред­положим, вы хотите написать функцию для выво­да обратного отсчета:
**1...2...3**
Ее можно записать в рекурсивном виде:
```JavaScript
function countdown(i) {
    console.log(i);
    countdown(i - 1);
}
```
И тут возникает проблема: эта функция выполняется бесконечно!

Когда вы пишете рекурсивную функцию, в ней необходимо указать, в ка­кой момент следует прервать рекурсию. Вот почему каждая рекурсивная функция состоит из двух частей: 
1. базового случая;
2. рекурсивного случая;

В рекурсивном случае функция вызывает сама себя. В базовом случае функция себя не вызывает чтобы предотвратить зацикливание.
Добавим базовый случай в функцию countdown:
```JavaScript
function countdown(i) {
    console.log(i);
    if(i <= 0) {
        return;
    } else {
        countdown(i - 1);
    }
}
```
Теперь функция работает так, как было задумано.

### Стек
Концепция стека вызовов играет важную роль в программировании вообще; кроме того, ее важно понимать при использовании рекурсии.

Предположим, вы устраиваете вечеринку с барбекю. Вы составляете спи­сок задач и записываете дела на листках.

Новые (вставленные) элементы добавляются в начало списка, то есть на верх стопки. Читается только верхний элемент, и он исключается из списка. Таким образом, список задач поддерживает всего два действия: занесение (вставка) и извлечение (выведение из списка и чтение.)

Такая структура данных называется стеком. Стек - простая структура дан­ных. А теперь самое неожиданное: все это время вы пользовались стеком, не подозревая об этом!

### Стек вызовов
Во внутренней работе вашего компьютера используется стек, называемый стеком вызовов. Давайте посмотрим, как он работает. Предположим, име­ется простая функция:
```JavaScript
function greet(name) {
    alert("hello, " + name + "!"); 
    greet2(name);
    alert("getting ready to say bye..."); 
    bye();
}
```
Эта функция приветствует вас, после чего вызывает две другие функции. Вот эти две функции:
```JavaScript
function greet2(name) {
    alert("how are you, " + name + "?");
}
function bye() {
    alert("ok bye!");
}
```

Предположим, в программе используется вызов greet("maggie"). Сначала ваш компьютер выделяет блок памяти для этого вызова функции.

Затем эта память используется. Переменной name присваивается значение "maggie"; оно должно быть сохранено в памяти.

Каждый раз, когда вы вызываете функцию, компьютер сохраняет в памяти значения всех переменных для этого вызова. Далее выводится приветствие hello, maggie!, после чего следует второй вызов greet2("maggie"). И снова компьютер выделяет блок памяти для вызова функции.

Ваш компьютер объединяет эти блоки в стек. Второй блок создается над первым. Вы выводите сообщение how are you, maggie?, после чего воз­вращаете управление из вызова функции. Когда это происходит, блок на вершине стека извлекается из него.

Теперь верхний блок в стеке относится к функции greet; это означает, что вы вернулись к функции greet. При вызове функции greet2 функция greet еще не была завершена. Здесь-то и скрывается истинный смысл этого раз­дела: *когда вы вызываете функцию из другой функции, вызывающая функция приостанавливается в частичоо завершеноом состоянии.* Все значения пере­менных этой функции остаются в памяти. А когда выполнение функции greet2 будет завершено, вы вернетесь к функции greet и продолжите ее выполнение с того места, где оно прервалось. Сначала выводится сообщение getting ready to say bye..., после чего вызывается функция bye.

Блок для этой функции добавляется на вершину стека. Далее выводится сообщение ok bye! с выходом из вызова функции.

Управление снова возвращается функции greet. Делать больше нечего, так что управление возвращается и из функции greet. Этот стек, в котором со­хранялись переменные разных функций, называется *стеком вызовов*.

### Стек вызовов с рекурсией
Рекурсивные функции тоже используют стек вызовов! Посмотрим, как это делается, на примере функции вычисления факториала. Вызов factorial(S) записывается в виде 5! и определяется следующим образом: 5! = 5*4*3*2*1. По тому же принципу factorial(З) соответствует 3*2*1. Рекурсивная функ­ция для вычисления факториала числа выглядит так:
```JavaScript
function fact(x) {
    if(x === 1) {
        return 1;
    } else {
        return x * fact(x - 1);
    }
}
```

Стек удобен, но у него есть своя цена: сохранение всей промежуточной информации может привести к значительным затратам памяти. Каждый вызов функции занимает не много памяти, но если стек станет слишком высоким, это будет означать, что ваш компьютер сохраняет информацию по очень многим вызовам. На этой стадии есть два варианта:
* Переписать код с использованием цикла.
* Иногда можно воспользоваться так называемой *хвостовой рекурсией*. Это непростая тема, которая выходит за рамки книги. Вдобавок она под­ держивается далеко не во всех языках.

#### Шпаргалка
* Когда функция вызывает саму себя, это называется рекурсией.
* В каждой рекурсивной функции должно быть два случая: базовый и рекурсивный.
* Стек поддерживает две операции: зане­сение и извлечение элементов.
* Все вызовы функций сохраняются в сте­ке вызовов.
* Если стек вызовов станет очень большим, он займет слишком много памяти.
