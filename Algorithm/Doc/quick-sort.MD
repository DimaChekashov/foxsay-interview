## Быстрая сортировка
Быстрая сортировка относится к алгоритмам сортиров­ки. Она работает намного быстрее сортировки выбором и часто применяется в реальных программах. Например, в стандартную библиотеку С входит функция с име­нем qsort, реализующая быструю сортировку. Быстрая сортировка также основана на стратегии **разделяй и властвуй**.

Воспользуемся быстрой сортировкой для упорядо­чения массива. Как выглядит самый простой массив, с которым может справиться алгоритм сортировки? Не­ которые массивы вообще не нуждаются в сорти­ровке.

Пустые массивы и массивы, содержащие всего один элемент, станут базо­вым случаем. Такие массивы можно просто возвращать в исходном виде - сортировать ничего не нужно:
```JavaScript
function quicksort(array) {
    if(array.length < 2) {
        return array;
    }
}
```

Теперь перейдем к массивам большего размера. Массив из двух элементов тоже сортируется без особых проблем.
*Сравниваем два элемента. если первый элемент меньше второго, меняем их местами*

А как насчет массива из трех элементов?
Массив должен разделяться до тех пор, пока мы не придем к базовому случаю. Алгоритм быстрой сортировки работает так: сначала в массиве выбирается элемент, который называется опорным.

Предположим, что опорным становится первый элемент массива.
Теперь мы находим элементы, меньшие опорного, и элементы, большие опорного.

Этот процесс называется разделением. Теперь у вас имеются:
* подмассив всех элементов, меньших опорного;
* опорный элемент;
* подмассив всех элементов, больших опорного.
Два подмассива не отсортированы - они просто выделены из исходного массива. Но если бы они были отсортированы, то провести сортировку всего массива было бы несложно.

Если бы подмассивы были отсортированы, то их можно было бы объеди­нить в порядке **левый подмассив - опорный элемент - правый подмас­сив** и получить отсортированный массив. В нашем примере получается [10, 15] + [ 33] + [] = [ 10, 15, 33], то есть отсортированный массив.

Как отсортировать подмассивы? Базовый случай быстрой сортировки уже знает, как сортировать массивы из двух элементов (левый подмассив) и пустые массивы (правый подмассив). Следовательно, если применить алгоритм быстрой сортировки к двум подмассивам, а затем объединить результаты, получится отсортированный массив!

**quicksort([lS, 10]) + [33) + quicksort([])**
**> [ 10, 15, 33]**
Этот метод работает при любом опорном элементе. Допустим, вместо 33 в качестве опорного был выбран элемент 15.

Оба подмассива состоят из одного элемента, а вы уже умеете сортировать такие подмассивы. Получается, что вы умеете сортировать массивы из трех элементов. Это делается так:
1. Выбрать опорный элемент.
2. Разделить массив на два подмассива: элементы, меньшие опорного, и элементы, большие опорного.
3. Рекурсивно применить быструю сортировку к двум подмассивам.

Как насчет массива из четырех элементов?
Предположим, опорным снова выбирается элемент 33.
Левый подмассив состоит из трех элементов. Вы уже знаете, как сортирует­ся массив из трех элементов: нужно рекурсивно применить к нему быструю сортировку.
Следовательно, вы можете отсортировать массив из четырех элементов.

А вот как выглядит программный код быстрой сортировки:
```JavaScript
function quicksort(array) {
    if(array.length < 2) {
        return array;
    }
    
    let pivot = array[0];
    let less = [];
    let greater = [];

    for(let i = 1; i < array.length; i++) {
        if(array[i] < pivot) {
            less.push(array[i]);
        } else {
            greater.push(array[i]);
        }
    }

    return [...quicksort(less), pivot, ...quicksort(greater)];
}
```

### Об «О-большом»
Алгоритм быстрой сортировки уникален тем, что его скорость зависит от выбора опорного элемента. Прежде чем рассматривать быструю сорти­ровку, вспомним наиболее типичные варианты времени выполнения для **O-большое**.

Для каждого времени выполнения также приведен пример алгоритма. Возьмем алгоритм сортировки выбором. Он обладает временем О(n2), и это довольно медленный алгоритм.

Другой алгоритм сортировки - так называемая сортировка слиянием - работает за время О(n log n). Намного быстрее! С быстрой сортировкой дело обстоит сложнее. В худшем случае быстрая сортировка работает за время О(n^2).

Ничуть не лучше сортировки выбором! Но это худший случай, а в среднем быстрая сортировка выполняется за время О(n log n).

Вероятно, вы спро­сите:
* что в данном случае понимается под **худшим** и **средним** случаем?
* если быстрая сортировка в среднем выполняется за время О(n log n), а сортировка слиянием выполняется за время О(n log n) всегда, то по­ чему бы не использовать сортировку слиянием? Разве она не быстрее?

### Сортировка слиянием и быстрая сортировка
Допустим, у вас имеется простая функция для вывода каждого элемента в списке:
```JavaScript
function print_items(list) {
    for(let i = 0; i < list.length; i++) {
        console.log(list[i]);
    }
}
```
Эта функция последовательно перебирает все элементы списка и выво­дит их. Так как функция перебирает весь список, она выполняется за вре­мя О(n). Теперь предположим, что вы изменили эту функцию и она делает секундную паузу перед выводом:
```JavaScript
function print_items2(list) {
    for(let i = 0; i < list.length; i++) {
        setTimeout(() => {
            console.log(list[i]);
        }, 1000)
    }
}
```
Перед выводом элемента функция делает паузу продолжительностью в 1 секунду. Предположим, вы выводите список из пяти элементов с ис­пользованием обеих функций:
|2|4|6|8|10|
print_items: 2 4 6 8 10
print_items2: пауза 2 пауза 4 пауза 6 пауза 8 пауза 10

Обе функции проходят по списку один раз, и обе выполняются за вре­ мя О(n). Как вы думаете, какая из них работает быстрее? Я думаю, print_items работает намного быстрее, потому что она не делает паузу перед вы­водом каждого элемента. Следовательно, даже при том, что обе функции имеют одинаковую скорость **О-большое**, реально print_items работает быстрее. Когда вы используете **О-большое** (например, О(n)), в действи­тельности это означает следующее:
**фиксированный промежуток времени * n**

Здесь с - некоторый фиксированный промежуток времени для вашего алгоритма. Он называется константой. Например, время выполнения может составлять 10 миллисекунд * n для print_items против 1 секунды * n для print_items2.

Обычно константа игнорируется, потому что если два алгоритма имеют разное время **О-большое**, она роли не играет. Для примера возьмем би­нарный и простой поиск. Допустим, такие константы присутствуют в обоих алгоритмах.
Простой поиск: 10мс * n
Бинарный поиск: 1c * log n

Первая реакция: **Ого! У простого поиска константа равна 10 миллисекун­дам, а у бинарного поиска - 1 секунда. Простой поиск намного быстрее!** Теперь предположим, что поиск ведется по списку из 4 миллиардов элемен­тов. Время будет таким:
Простой поиск: 10мс * 4 миллиарда = 463 дня
Бинарный поиск: 1c * 32 = 32с

Как видите, бинарный поиск все равно работает намного быстрее. Констан­та ни на что не повлияла.

Однако в некоторых случаях константа может иметь значение. Один из примеров такого рода - быстрая сортировка и сортировка слиянием. У бы­строй сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то Что оба алгоритма характеризуются временем О(n log n), быстрая сортировка работает быстрее. А на практике быстрая сортировка работает быстрее, потому что средний случай встречается намного чаще худшего.

### Средний и худший случай
Быстродействие быстрой сортировки сильно зависит от выбора опорного элемента. Предположим, опорным всегда выбирается первый элемент, а бы­страя сортировка применяется к уже отсортированному массиву. Быстрая сортировка не проверяет, отсортирован входной массив или нет, и все равно пытается его отсортировать.

На этот раз массив не разделяется на две половины. Вместо этого один из двух подмассивов всегда пуст, так что стек вызовов получается очень длинным. Теперь предположим, что в качестве опорного всегда выбирается средний элемент.

Стек намного короче! Массив каждый раз делится надвое, поэтому такое количество рекурсивных вызовов излишне. Вы быстрее добираетесь до базового случая, и стек вызовов получается более коротким.

Первый из рассмотренных примеров описывает худший сценарий, а вто­рой - лучший. В худшем случае размер стека описывается как О(n). В лучшем случае он составит O(log n).

Теперь рассмотрим первый уровень стека. Один элемент выбирается опор­ным, а остальные элементы делятся на подмассивы. Вы перебираете все восемь элементов массива, поэтому первая операция выполняется за вре­ мя О(n). На этом уровне стека вызовов вы обратились ко всем восьми элементам. Но на самом деле вы обращаетесь к О(n) элементам на каждом уровне стека вызовов!

Даже если массив будет разделен другим способом, вы все равно каждый раз обращаетесь к О(n) элементам.

А теперь сюрприз: лучший случай также является средним. Если вы всегда будете выбирать опорным элементом случайный элемент в массиве, бы­страя сортировка в среднем завершится за время О(n log n). Это один из самых быстрых существующих алгоритмов сортировки, который заодно является хорошим примером стратегии «разделяй и властвуй».

### Шпаргалка
* Стратегия **разделяй и властвуй** основана на разбиении задачи на уменьшающиеся фрагменты. Если вы используете стратегию **разделяй и вла­ствуй** со списком, то базовым случаем, скорее всего, является пустой массив или массив из одного элемента.
* Если вы реализуете алгоритм быстрой сортировки, выберите в качестве опорного случайный элемент. Среднее время выполнения быстрой сортировки составляет О(n log n)!
* Константы в «О-большом» иногда могут иметь значение. Именно по этой причине быстрая сортировка быстрее сортировки слиянием.
* При сравнении простой сортировки с бинарной константа почти никогда роли не играет, потому что O(log n) слишком сильно превосходит О(n) по скорости при большом размере списка.
