## Хеш-таблицы
Хеш-функция представляет собой функцию, которая получает строку и возвращает число.

В научной терминологии говорят, что хеш-функция **отображает строки на числа**. Можно подумать, что найти закономерности получения чисел для подаваемых на вход строк невозможно. Однако хеш-функция должна соответствовать некоторым требованиям:
* Она должна быть последовательной. Допустим, вы передали ей стро­ку **апельсины** и получили 4. Это значит, что каждый раз в будущем, передавая ей строку «апельсины», вы будете получать 4. Без этого хеш­ таблица бесполезна.
* Разным словам должны соответствовать разные числа. Например, хеш­ функция, которая возвращает 1 для каждого полученного слова, никуда не годится. В идеале каждое входное слово должно отображаться на свое число.

Итак, хеш-функция связывает строки с числами. Зачем это нужно, спросите вы? Так ведь это позволит нам реализовать **Мэгги**!

Начнем с пустого массива:
Все цены будут храниться в этом массиве; передадим хеш-функции строку **апельсины**.

Хеш-функция выдает значение «3». Сохраним цену апельсинов в элементе массива с индексом 3.

Добавим молоко. Передадим хеш-функции строку «молоко».

Продолжайте действовать так, и со временем весь массив будет заполнен ценами на товары.

А теперь вы спрашиваете: сколько стоит авокадо? Искать в массиве ничего не нужно, просто передайте строку «авокадо» хеш-функции.

Результат показывает, что значение хранится в элементе с индексом 4. И оно, конечно, там и находится!

Хеш-функция сообщает, где хранится цена, и вам вообще не нужно ничего искать! Такое решение работает, потому что:
* Хеш-функция неизменно связывает название с одним индексом. Каждый раз, когда она вызывается для строки «авокадо», вы получаете обратно одно и то же число. При первом вызове этой функции вы узнаете, где следует сохранить цену авокадо, а при последующих вызовах она со­общает, где взять эту цену.
* Хеш-функция связывает разные строки с разными индексами. «Авока­ до» связывается с индексом 4, а «молоко» - с индексом О. Для каждой строки находится отдельная позиция массива, в которой сохраняется цена этого товара.
* Хеш-функция знает размер массива и возвращает только действитель­ные индексы. Таким образом, если длина массива равна 5 элементам, хеш-функция не вернет 100, потому что это значение не является дей­ствительным индексом в массиве.

Поздравляю: вы создали «Мэгги»!

Свяжите воедино хеш-функцию и массив, и вы получите структуру данных, которая называется хеш-таблицей. Хеш-таблица станет первой изученной вами структурой данных, с которой связана дополнительная логика. Массивы и списки напрямую отображают­ся на адреса памяти, но хеш-таблицы устроены более умно. Они определяют место хранения элементов при помощи хеш-функций.

Вероятно, хеш-таблицы станут самой полезной из сложных структур дан­ных, с которыми вы познакомитесь. Они также известны под другими названиями: «ассоциативные массивы», «словари», «отображения», «хеш­ карты» или просто «хеши». Хеш-таблицы исключительно быстро работают! Помните описание массивов и связанных списков из главы 2? Обращение к элементу массива происходит мгновенно. А хеш-таблицы используют массивы для хранения данных, поэтому при обращении к элементам они не уступают массивам.

Скорее всего, вам никогда не придется заниматься реализацией хеш-таблиц самостоятельно. В любом приличном языке существует реализация хеш­ таблиц.
book - новая хеш-таблица. Добавим в book несколько цен:
```Java
import java.util.Hashtable;
 
public class Main {
    public static void main(String[] args) {
        Hashtable<String, Float> book = new Hashtable<>();

        book.put("apple", 0.67);
        book.put("milk", 1.49);
        book.put("avocado", 1.49);

        System.out.println(book.get("avocado")); // 1.49
    }
}
```
Хеш-таблица состоит из ключей и значений. В хеше book имена продуктов являются ключами, а цены - значениями. Хеш-таблица связывает ключи со значениями.

В следующем разделе приведены примеры, в которых хеш-таблицы приносят большую пользу.

Очень важно, чтобы хеш-функции были последова­тельными, то есть неизменно возвращали один и тот же результат для одинаковых входных данных. Если это условие будет нарушено, вы не сможете най­ти свой элемент после того, как он будет помещен в хеш-таблицу!

### Использование хеш-таблиц для поиска
В вашем телефоне есть удобная встроенная телефонная книга.
С каждым именем связывается номер телефона.

Предположим, вы хотите построить такую телефонную книгу. Имена людей в этой книге связываются с номерами. Телефонная книга должна поддер­живать следующие функции:
* добавление имени человека и номера телефона, связанного с этим име­нем;
* получение номера телефона, связанного с введенным именем.
Такая задача идеально подходит для хеш-таблиц! Хеш-таблицы отлично работают, когда вы хотите:
* создать связь, отображающую один объект на другой;
* найти значение в списке.
Построить телефонную книгу, в общем-то, несложно. Начните с создания новой хеш-таблицы:
```Java
import java.util.Hashtable;
 
public class Main {
    public static void main(String[] args) {
        Hashtable<String, Integer> phone_book = new Hashtable<>();
    }
}
```
Добавим в телефонную книгу несколько номеров:
```Java
phone_book.put("jenny", 8675309);
phone_book.put("emergency", 911);
```
Вот и все! Теперь предположим, что вы хотите найти номер телефона Джен­ни. Просто передайте ключ хешу:
```Java
phone_book.get("jenny"); // 8675309
```
А теперь представьте, что то же самое вам при­шлось бы делать с массивом.
Как бы вы это сделали? Хеш-таблицы упро­щают моделирование отношений между объ­ектами.

Хеш-таблицы используются для поиска соответствий в гораздо большем масштабе. Например, представьте, что вы хотите перейти на веб-сайт - до­ пустим, http://adit.io. Ваш компьютер должен преобразовать символическое имя adit.io в IР-адрес.
ADIT.IO -> 173.255.248.55
Для любого посещаемого веб-сайта его имя преобразуется в IР-адрес:
google.com -> 74.125.239.133
Связать символическое имя с IР-адресом? Идеальная задача для хеш­ таблиц! Этот процесс называется преобразованием DNS. Хеш-таблицы - всего лишь один из способов реализации этой функциональности.

### Исключение дубликатов
Предположим, вы руководите избирательным участ­ком. Естественно, каждый избиратель может про­голосовать всего один раз. Как проверить, что он не голосовал ранее? Когда человек приходит голосовать, вы узнаете его полное имя, а затем проверяете по спи­ску уже проголосовавших избирателей.

Если имя входит в список, значит, этот человек уже проголосовал - наглеца! В противном случае вы добавляете имя в список и разрешаете ему проголосовать. Теперь предположим, что желающих проголосовать много и список уже проголосовавших достаточно велик.

Каждый раз, когда кто-то приходит голосовать, вы вынуждены просматри­ вать этот гигантский список и проверять, голосовал он или нет. Однако существует более эффективное решение: воспользоваться хешем!

Сначала создадим хеш для хранения информации об уже проголосовавших людях.
Когда кто-то приходит голосовать, проверьте, присутствует ли его имя в хеше.
Функция get возвращает значение, если ключ "tom" присутствует в хеш­ таблице. В противном случае возвращается None. С помощью этой функции можно проверить, голосовал избиратель ранее или нет!
Код выглядит так:
```Java
import java.util.Hashtable;
 
public class Main {
    public static void main(String[] args) {
        Hashtable<String, Boolean> voted = new Hashtable<>();

        check_voter("tom", voted); // let them vote!
        check_voter("mike", voted); // let them vote!
        check_voter("mike", voted); // Kick them out!
    }

    public static void check_voter(String name, Hashtable<String, Boolean> voted) {
        if(voted.get(name) != null) {
            System.out.println("Kick them out!");
        } else {
            voted.put(name, true);
            System.out.println("Let them vote!");
        }
    }
}
```
Когда Том приходит на участок в первый раз, программа разрешает ему проголосовать. Потом приходит Майк, который тоже допускается к голосо­ванию. Но потом Майк делает вторую попытку, и на этот раз у него ничего не получается.

Если бы имена проголосовавших хранились в списке, то выполнение функции со временем замедлилось бы, потому что функции пришлось бы проводить простой поиск по всему списку. Но имена хранятся в хеш­ таблице, а хеш-таблица мгновенно сообщает, присутствует имя избирателя в списке или нет. Проверка дубликатов в хеш-таблице выполняется очень быстро.