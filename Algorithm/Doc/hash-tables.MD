## Хеш-таблицы
Хеш-функция представляет собой функцию, которая получает строку и возвращает число.

В научной терминологии говорят, что хеш-функция **отображает строки на числа**. Можно подумать, что найти закономерности получения чисел для подаваемых на вход строк невозможно. Однако хеш-функция должна соответствовать некоторым требованиям:
* Она должна быть последовательной. Допустим, вы передали ей стро­ку **апельсины** и получили 4. Это значит, что каждый раз в будущем, передавая ей строку «апельсины», вы будете получать 4. Без этого хеш­ таблица бесполезна.
* Разным словам должны соответствовать разные числа. Например, хеш­ функция, которая возвращает 1 для каждого полученного слова, никуда не годится. В идеале каждое входное слово должно отображаться на свое число.

Итак, хеш-функция связывает строки с числами. Зачем это нужно, спросите вы? Так ведь это позволит нам реализовать **Мэгги**!

Начнем с пустого массива:
Все цены будут храниться в этом массиве; передадим хеш-функции строку **апельсины**.

Хеш-функция выдает значение «3». Сохраним цену апельсинов в элементе массива с индексом 3.

Добавим молоко. Передадим хеш-функции строку «молоко».

Продолжайте действовать так, и со временем весь массив будет заполнен ценами на товары.

А теперь вы спрашиваете: сколько стоит авокадо? Искать в массиве ничего не нужно, просто передайте строку «авокадо» хеш-функции.

Результат показывает, что значение хранится в элементе с индексом 4. И оно, конечно, там и находится!

Хеш-функция сообщает, где хранится цена, и вам вообще не нужно ничего искать! Такое решение работает, потому что:
* Хеш-функция неизменно связывает название с одним индексом. Каждый раз, когда она вызывается для строки «авокадо», вы получаете обратно одно и то же число. При первом вызове этой функции вы узнаете, где следует сохранить цену авокадо, а при последующих вызовах она со­общает, где взять эту цену.
* Хеш-функция связывает разные строки с разными индексами. «Авока­ до» связывается с индексом 4, а «молоко» - с индексом О. Для каждой строки находится отдельная позиция массива, в которой сохраняется цена этого товара.
* Хеш-функция знает размер массива и возвращает только действитель­ные индексы. Таким образом, если длина массива равна 5 элементам, хеш-функция не вернет 100, потому что это значение не является дей­ствительным индексом в массиве.

Поздравляю: вы создали «Мэгги»!

Свяжите воедино хеш-функцию и массив, и вы получите структуру данных, которая называется хеш-таблицей. Хеш-таблица станет первой изученной вами структурой данных, с которой связана дополнительная логика. Массивы и списки напрямую отображают­ся на адреса памяти, но хеш-таблицы устроены более умно. Они определяют место хранения элементов при помощи хеш-функций.

Вероятно, хеш-таблицы станут самой полезной из сложных структур дан­ных, с которыми вы познакомитесь. Они также известны под другими названиями: «ассоциативные массивы», «словари», «отображения», «хеш­ карты» или просто «хеши». Хеш-таблицы исключительно быстро работают! Помните описание массивов и связанных списков из главы 2? Обращение к элементу массива происходит мгновенно. А хеш-таблицы используют массивы для хранения данных, поэтому при обращении к элементам они не уступают массивам.

Скорее всего, вам никогда не придется заниматься реализацией хеш-таблиц самостоятельно. В любом приличном языке существует реализация хеш­ таблиц.
book - новая хеш-таблица. Добавим в book несколько цен:
```Java
import java.util.Hashtable;
 
public class Main {
    public static void main(String[] args) {
        Hashtable<String, Float> book = new Hashtable<>();

        book.put("apple", 0.67);
        book.put("milk", 1.49);
        book.put("avocado", 1.49);

        System.out.println(book.get("avocado")); // 1.49
    }
}
```
Хеш-таблица состоит из ключей и значений. В хеше book имена продуктов являются ключами, а цены - значениями. Хеш-таблица связывает ключи со значениями.

В следующем разделе приведены примеры, в которых хеш-таблицы приносят большую пользу.

Очень важно, чтобы хеш-функции были последова­тельными, то есть неизменно возвращали один и тот же результат для одинаковых входных данных. Если это условие будет нарушено, вы не сможете най­ти свой элемент после того, как он будет помещен в хеш-таблицу!

### Использование хеш-таблиц для поиска
В вашем телефоне есть удобная встроенная телефонная книга.
С каждым именем связывается номер телефона.

Предположим, вы хотите построить такую телефонную книгу. Имена людей в этой книге связываются с номерами. Телефонная книга должна поддер­живать следующие функции:
* добавление имени человека и номера телефона, связанного с этим име­нем;
* получение номера телефона, связанного с введенным именем.
Такая задача идеально подходит для хеш-таблиц! Хеш-таблицы отлично работают, когда вы хотите:
* создать связь, отображающую один объект на другой;
* найти значение в списке.
Построить телефонную книгу, в общем-то, несложно. Начните с создания новой хеш-таблицы:
```Java
import java.util.Hashtable;
 
public class Main {
    public static void main(String[] args) {
        Hashtable<String, Integer> phone_book = new Hashtable<>();
    }
}
```
Добавим в телефонную книгу несколько номеров:
```Java
phone_book.put("jenny", 8675309);
phone_book.put("emergency", 911);
```
Вот и все! Теперь предположим, что вы хотите найти номер телефона Джен­ни. Просто передайте ключ хешу:
```Java
phone_book.get("jenny"); // 8675309
```
А теперь представьте, что то же самое вам при­шлось бы делать с массивом.
Как бы вы это сделали? Хеш-таблицы упро­щают моделирование отношений между объ­ектами.

Хеш-таблицы используются для поиска соответствий в гораздо большем масштабе. Например, представьте, что вы хотите перейти на веб-сайт - до­ пустим, http://adit.io. Ваш компьютер должен преобразовать символическое имя adit.io в IР-адрес.
ADIT.IO -> 173.255.248.55
Для любого посещаемого веб-сайта его имя преобразуется в IР-адрес:
google.com -> 74.125.239.133
Связать символическое имя с IР-адресом? Идеальная задача для хеш­ таблиц! Этот процесс называется преобразованием DNS. Хеш-таблицы - всего лишь один из способов реализации этой функциональности.

### Исключение дубликатов
Предположим, вы руководите избирательным участ­ком. Естественно, каждый избиратель может про­голосовать всего один раз. Как проверить, что он не голосовал ранее? Когда человек приходит голосовать, вы узнаете его полное имя, а затем проверяете по спи­ску уже проголосовавших избирателей.

Если имя входит в список, значит, этот человек уже проголосовал - наглеца! В противном случае вы добавляете имя в список и разрешаете ему проголосовать. Теперь предположим, что желающих проголосовать много и список уже проголосовавших достаточно велик.

Каждый раз, когда кто-то приходит голосовать, вы вынуждены просматри­ вать этот гигантский список и проверять, голосовал он или нет. Однако существует более эффективное решение: воспользоваться хешем!

Сначала создадим хеш для хранения информации об уже проголосовавших людях.
Когда кто-то приходит голосовать, проверьте, присутствует ли его имя в хеше.
Функция get возвращает значение, если ключ "tom" присутствует в хеш­ таблице. В противном случае возвращается None. С помощью этой функции можно проверить, голосовал избиратель ранее или нет!
Код выглядит так:
```Java
import java.util.Hashtable;
 
public class Main {
    public static void main(String[] args) {
        Hashtable<String, Boolean> voted = new Hashtable<>();

        check_voter("tom", voted); // let them vote!
        check_voter("mike", voted); // let them vote!
        check_voter("mike", voted); // Kick them out!
    }

    public static void check_voter(String name, Hashtable<String, Boolean> voted) {
        if(voted.get(name) != null) {
            System.out.println("Kick them out!");
        } else {
            voted.put(name, true);
            System.out.println("Let them vote!");
        }
    }
}
```
Когда Том приходит на участок в первый раз, программа разрешает ему проголосовать. Потом приходит Майк, который тоже допускается к голосо­ванию. Но потом Майк делает вторую попытку, и на этот раз у него ничего не получается.

Если бы имена проголосовавших хранились в списке, то выполнение функции со временем замедлилось бы, потому что функции пришлось бы проводить простой поиск по всему списку. Но имена хранятся в хеш­ таблице, а хеш-таблица мгновенно сообщает, присутствует имя избирателя в списке или нет. Проверка дубликатов в хеш-таблице выполняется очень быстро.

### Использование хеш-таблицы как кэша
Последний пример: кэширование. Если вы ра­ботаете над созданием веб-сайтов, вероятно, вы уже слышали о пользе кэширования. Общая идея кэширования такова: допустим, вы захо­дите на сайт facebook.com:
1. Вы обращаетесь с запросом к серверу Facebook.
2. Сервер не надолго задумывается, генерирует веб-страницу и отправляет ее вам.
3. Вы получаете веб-страницу.

Например, на Facebook сервер может собирать информацию о действиях всех ваших друзей, чтобы представить ее вам. На то, чтобы собрать всю информацию и передать ее вам, требуется пара секунд. С точки зрения пользователя, парасекунд - это очень долго. Он начинает думать: «Почему Facebook работает так медленно?» С другой стороны, серверам Facebook приходится обслуживать миллионы людей, и эти пары секунд для них суммируются. Серверы Facebook трудятся в полную силу, чтобы сгенери­ровать все эти страницы. Нельзя ли как-то ускорить работу Facebook при том, чтобы серверы выполняли меньше работы?

Представьте, что у вас есть племянница, которая пристает к вам с вопро­ сами о планетах: «Сколько километров от Земли до Марса?», «А сколько километров до Луны?», «А до Юпитера?» Каждый раз вы вводите запрос в Google и сообщаете ей ответ. На это уходит пара минут. А теперь пред­ставьте, что она всегда спрашивает: «Сколько километров от Земли до Луны?» Довольно быстро вы запоминаете, что Луна находится на рас­ стоянии 384 400 километров от Земли. Искать информацию в Google не нужно... Бы просто запоминаете и выдаете ответ. Вот так работает меха­низм кэширования: сайт просто запоминает данные, вместо того чтобы пересчитывать их заново.

Если вы вошли на Facebook, то весь контент, который вы видите, адапти­рован специально для вас. Каждый раз, когда вы заходите нa facebook.com, серверам приходится думать, какой контент вас интересует. Если же вы не ввели учетные данные на Facebook, то вы видите страницу входа. Все поль­зователи видят одну и ту же страницу входа. Facebook постоянно получает одинаковые запросы: **Я еще не вошел на сайт, выдайте мне домашнюю страницу**. Сервер перестает выполнять лишнюю работу и генерировать домашнюю страницу снова и снова. Вместо этого он запоминает, как вы­глядит домашняя страница, и отправляет ее вам.

Такой механизм хранения называется кэшированием. Он обладает двумя преимуществами:
* вы получаете веб-страницу намного быстрее, как и в том случае, когда вы запомнили расстояние от Земли до Луны. Когда племянница в сле­дующий раз задаст вопрос, вам не придется гуглить. Вы можете выдать ответ мгновенно;
* Facebook приходится выполнять меньше работы.

Кэширование - стандартный способ ускорения работы. Все крупные веб­-сайты применяют кэширование. А кэшируемые данные хранятся в хеше!

Facebook не просто кэширует домашнюю страницу. Также кэшируются стра­ ницы **0 нас**, **Условия использования** и многие другие. Следовательно, необходимо создать связь URL-aдpeca страницы и данных страницы.

Когда вы посещаете страницу на сайте Facebook, сайт сначала проверяет, хранится ли страница в хеше.

Вот как это выглядит в коде:
```JavaScript
    let cache = new Map();

    function get_page(url) {
        if(cache.has(url)) {
            return cache.get(url);
        } else {
            let data = get_data_from_server(url);
            cache.set(url, data);
            return data;
        }
    }
```
Здесь сервер выполняет работу только в том случае, если URL не хранится в кэше. Однако перед тем, как возвращать данные, вы сохраняете их в кэше. Когда пользователь в следующий раз запросит тот же URL-aдpec, данные можно отправить из кэша (вместо того чтобы заставлять сервер выполнять работу).

### Шпаргалка
Хеши хорошо подходят для решения следующих задач:
* моделирование отношений между объектами;
* устранение дубликатов;
* кэширование/запоминание данных вместо выполнения работы на сер­ вере.

### Коллизии
Как было уже сказано, в большинстве языков существуют свои хеш-таблицы. Вам не нужно знать, как написать собственную реализацию, поэтому нет необходимости надолго останавливаться на внутреннем строении хеш-таблиц. Но быстродействие-то важно всегда! Чтобы понять быстродействие хеш­ таблиц, необходимо сначала понять, что такое коллизии. В следующих двух разделах рассматриваются коллизии и быстродействие хеш-таблиц.

Прежде всего, я немножко приукрасил действительность. Я сказал, что хеш­ функция всегда отображает разные ключи на разные позиции в массиве.

На самом деле написать такую хеш-функцию почти невозможно. Рассмо­трим простой пример: допустим, массив состоит всего из 33 ячеек.

И хеш-функция очень простая: элемент массива просто назначается по алфавитному признаку.

Может быть, вы уже поняли суть проблемы. Вы хотите поместить цену апельсинов в хеш. Для этого выделяется первая ячейка.

После апельсинов в хеш заносится цена бананов. Для бананов выделяется вторая ячейка.

Пока все прекрасно! Но теперь в хеш нужно включить цену авокадо. И для авокадо снова выделяется первая ячейка.

О нет! Элемент уже занят апельсинами! Что же делать? Такая ситуация называется коллизией: двум ключам назначается один элемент массива. Возникает проблема: если сохранить в этом элементе цену авокадо, то она запишется на место цены апельсинов. И когда кто-нибудь спросит, сколько стоят апельсины, вы вместо этого сообщите цену авокадо! Коллизии - не­ приятная штука, и вам придется как-то разбираться с ними. Существует много разных стратегий обработки коллизий. Простейшая из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.

В этом примере и «апельсины», и «авокадо» отображаются на один элемент массива, поэтому в элементе создается связанный список. Если вам потре­буется узнать цену бананов, эта операция по-прежнему выполнится быстро. Если потребуется узнать цену апельсинов, работа пойдет чуть медленнее. Вам придется провести поиск по связанному списку, чтобы найти в нем «апельсины». Если связанный список мал, это не так страшно - поиск будет ограничен тремя или четырьмя элементами. Но предположим, что вы работаете в специализированной лавке, в которой продаются только продукты на букву «а».

Одну минуту! Вся хеш-таблица полностью пуста, кроме одной ячейки. И эта ячейка содержит огромный связанный список! Каждый элемент этой хеш-таблицы хранится в связанном списке. Ситуация ничуть не лучше той, когда все данные сразу хранятся в связанном списке. Работа с данными замедляется.

Из этого примера следуют два важных урока:
* выбор хеш-функции действительно важен. Хеш-функция, отображаю­щая все ключи на один элемент массива, никуда не годится. В идеале хеш-функция должна распределять ключи равномерно по всему хешу;
* если связанные списки становятся слишком длинными, работа с хеш-таблицей сильно замедляется. Но они не станут слишком длинными при использовании хорошей хеш-функции!

Хеш-функции играют важную роль. Хорошая хеш-функция создает мини­ мальное число коллизий. Как же выбрать хорошую хеш-функцию? Об этом в следующем разделе!

### Быстродействие
Глава началась с примера магазинчика. Вы хотели построить механизм, ко­торый мгновенно выдает цены на продукты. Что ж, хеш-таблицы работают очень быстро.

В среднем хеш-таблицы выполняют любые операции за время 0(1). Время О(1) *называется постоянным*. Ранее примеры постоянного времени вам еще не встречались. Оно не означает, что операции выполняются мгновенно; просто время остается постоянным независимо от размера хеш-таблицы. Например, вы знаете, что простой поиск выполняется за линейное время.
* Бинарный поиск работает быстрее - за логарифмическое время.
* Поиск данных в хеш-таблице выполняется за постоянное время.

В среднем случае хеш-таблицы работают действительно быстро.
В худшем случае все операции с хеш-таблицей выполняются за время О(n) (линейное время), а это очень медленно. Сравним хеш-таблицы с массива­ми и
списками.

Взгляните на средний случай для хеш-таблиц. При поиске хеш-таблицы не уступают в скорости массивам (получение значения по индексу). А при вставке и удалении они так же быстры, как и связанные списки. Получается, что они взяли лучшее от обеих структур! Но в худшем случае хеш-таблицы медленно выполняют все эти операции, поэтому очень важно избегать худшего случая быстродействия при работе с хеш-таблицами. А для этого следует избегать коллизий. Для предотвращения коллизий необходимы:
* низкий коэффициент заполнения;
* хорошая хеш-функция.

### Коэффициент заполнения
Коэффициент заполнения хеш-таблицы вычисляет­ся по простой формуле. *Количество элементов в хеш-таблице* / *общее количество элементов*

Хеш-таблицы используют массив для хранения данных, поэтому для вы­ числения коэффициента заполнения можно подсчитать количество за­полненных элементов в массиве.

По коэффициенту заполнения можно оценить количество пустых ячеек в хеш-таблице.

Предположим, в хеш-таблице нужно сохранить цены 100 товаров и хеш­ таблица состоит из 100 элементов. В лучшем случае каждому товару будет выделен отдельный элемент.

Коэффициент заполнения этой хеш-таблицы равен 1. А если хеш-таблица состоит всего из 50 элементов? Тогда ее коэффициент заполнения будет равен 2. Выделить под каждый товар отдельный элемент ни при каких условиях не удастся, потому что элементов попросту не хватит! Коэффи­циент заполнения больше 1 означает, что количество товаров превышает количество элементов в массиве.

С ростом коэффициента заполнения в хеш-таблицу приходится добавлять новые элементы, то есть изменять ее размер.

Представим, что хеш­-таблица приближается к заполнению.
Хеш-таблицу необходимо расширить. Расширение начинается с создания нового массива большего размера. Обычно в таком случае создается массив вдвое большего размера.
Теперь все эти элементы необходимо заново вставить в новую хеш-таблицу функцией hash:

С меньшим коэффициентом загрузки число коллизий уменьшается, и ваша табли­ца начинает работать более эффективно. Хорошее приближенное правило: изменяйте размер хеш-таблицы, когда коэффициент заполнения превышает 0,7. Но ведь на изменение размеров уходит много времени, скажете вы, и будете абсолютно правы! Да, изменение размеров требует значитель­ ных затрат ресурсов, поэтому оно не должно происходить слишком часто. В среднем хеш-таблицы работают за время 0(1) даже с изменением раз­ меров.

### Хорошая хеш-функция
Хорошая хеш-функция должна обеспечивать равномерное распределение значений в массиве.

Плохая хеш-функция создает скопления и порождает множество коллизий.

Какую хеш-функцию считать хорошей? К счастью, вам об этом никогда не придется беспокоиться - пусть об этом беспокоятся пожилые бородатые умники, сидящие в полутемных комнатах. Если вам интересна эта тема, поищите информацию об алгоритме SHA. Вы можете использовать этот алгоритм в своей хеш­ функции.

### Шпаргалка
Вам почти никогда не придется реализовать хеш-таблицу самостоятельно. Язык программирования, который вы используете, должен предоставить необходимую реализацию. Вы можете пользоваться хеш-таблицами Python, и при этом вам будет обеспечена производительность среднего случая: по­ стоянное время.

Хеш-таблицы чрезвычайно полезны, потому что они обеспечивают высокую скорость операций и позволяют по-разному моделировать данные. Воз­можно, вскоре выяснится, что вы постоянно используете их в своей работе.
* Хеш-таблица создается объединением хеш-функции с массивом.
* Коллизии нежелательны. Хеш-функция должна свести количество кол­лизий к минимуму.
* Хеш-таблицы обеспечивают очень быстрое выполнение поиска, вставки и удаления.
* Хеш-таблицы хорошо подходят для моделирования отношений между объектами.
* Как только коэффициент заполнения превышает 0,7, пора изменять раз­ мер хеш-таблицы.
* Хеш-таблицы используются для кэширования данных (например, на веб-серверах) .
* Хеш-таблицы хорошо подходят для обнаружения дубликатов.
