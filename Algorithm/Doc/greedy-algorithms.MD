## Жадные алгоритмы

### Задача составления расписания
Допустим, имеется учебный класс, в котором нужно провести как можно больше уроков. Вы получаете список уроков.

Провести в классе все уроки не получится, потому что некоторые из них перекрываются по времени.

Требуется провести в классе как можно больше уроков. Как отобрать уроки, чтобы полученный набор оказался самым большим из возможных?

Вроде бы сложная задача, верно? На самом деле алгоритм оказывается на удивление простым. Вот как он работает:
1. Выбрать урок, завершающийся раньше всех. Это первый урок, который будет проведен в классе.
2. Затем выбирается урок, начинающийся после завершения первого уро­ка. И снова следует выбрать урок, который завершается раньше всех остальных. Он становится вторым уроком в расписании.

Продолжайте действовать по тому же принципу - и мы получаем ответ! Давайте попробуем. Рисование заканчивается раньше всех уроков (в 10:00), поэтому мы выбираем именно его.
Теперь нужно найти следующий урок, который начинается после 10:00 и завершается раньше остальных.
Английский язык отпадает - он перекрывается с рисованием, но матема­тика подходит. Наконец, информатика перекрывается с математикой, но музыка подходит.

И так, эти три урока должны проводиться в классе.

Я очень часто слышу, что этот алгоритм подозрительно прост. Он слишком очевиден, а значит, должен быть неправильным. Но в этом и заключается красота жадных алгоритмов: они просты! Жадный алгоритм прост: на каж­ дом шаге он выбирает оптимальный вариант. В нашем примере при выборе урока выбирается тот урок, который завершается раньше других. В техни­ ческой терминологии: на каждом шаге выбирается **локально-оптимальное решение**, а в итоге вы получаете глобально-оптимальное решение. Хотите верьте, хотите нет, но этот простой алгоритм успешно находит оптимальное решение задачи составления расписания!

Конечно, жадные алгоритмы работают не всегда. Но они так просто реали­зуются!

### Задача о рюкзаке
Представьте, что вы жадный воришка. Вы забрались в магазин с рюкзаком, и перед вами множество товаров, которые вы можете украсть. Однако емкость рюкзака не бесконечна: он выдержит не более 35 фунтов.
Требуется подобрать набор то­варов максимальной стоимости, которые можно сложить в рюкзак. Какой алгоритм вы будете использовать?
И снова жадная стратегия выглядит очень просто:
1. Выбрать самый дорогой предмет, который поместится в рюкзаке.
2. Выбрать следующий по стоимости предмет, который поместится в рюк­заке... И так далее.

Вот только на этот раз она не работает! Предположим, есть три предмета.
В рюкзаке поместятся товары общим весом не более 35 фунтов. Самый до­рогой товар - магнитофон, вы выбираете его. Теперь ни для чего другого места уже не осталось.

Вы набрали товаров на $3000. Погодите-ка! Если бы вместо магнитофона вы выбрали ноутбук и гитару, то стоимость добычи составила бы $3500!

Очевидно, жадная стратегия не дает оптимального решения. Но вор, забравшийся в магазин, врядли станет стремиться к идеалу. *достаточно хорошего* решения должно хватить.

Второй пример приводит нас к следующему выводу: иногда идеальное - враг хорошего. В некоторых случаях достаточно алгоритма, способного решить задачу достаточно хорошо. И в таких областях жадные алгоритмы работают просто отлично, потому что они просто реализуются, а получен­ ное решение обычно близко к оптимуму.

### Задача о покрытии множества
Вы открываете собственную авторскую програм­му на радио и хотите, чтобы вас слушали во всех 50 штатах. Нужно решить, на каких радиостанци­ях должна транслироваться ваша передача. Каждая станция стоит денег, поэтому количество станций не­ обходимо свести к минимуму. Имеется список станций.

Каждая станция покрывает определенный набор штатов, эти наборы пере­крываются.

Как найти минимальный набор станций, который бы покрывал все 50 шта­тов? Вроде бы простая задача, верно? Оказывается, она чрезвычайно слож­на. Вот как это делается:
1. Составить список всех возможных подмножеств станций - так на­зываемое *степенное множество*. В нем содержатся 2^n возможных подмножеств.
2. Из этого списка выбирается множество с наименьшим набором станций, покрывающих все 50 штатов.

Проблема в том, что вычисление всех возможных подмножеств станций займет слишком много времени. Для n станций оно потребует време­ни 0(2^n). Если станций немного, скажем от 5 до 10, - это допустимо. Но подумайте, что произойдет во всех рассмотренных примерах при большом количестве элементов. Предположим, вы можете вычислять по 10 подмно­жеств в секунду.

Не существует алгоритма, который будет вычислять подмножества с при­емлемой скоростыо! Что же делать?

### Приближенные алгоритмы
На помощь приходят жадные алгоритмы! Вот как выглядит жадный алго­ритм, который выдает результат, достаточно близкий к оптимуму:
1. Выбрать станцию, покрывающую наибольшее количество штатов, еще не входящих в покрытие. Если станция будет покрывать некоторые штаты, уже входящие в покрытие, это нормально.
2. Повторять, пока остаются штаты, не входящие в покрытие.

Этот алгоритм является *приближенным*. Когда вычисление точного реше­ния занимает слишком много времени, применяется приближенный алго­ритм. Эффективность приближенного алгоритма оценивается по:
* быстроте;
* близости полученного решения к оптимальному.

Жадные алгоритмы хороши не только тем, что они обычно легко формули­руются, но и тем, что простота обычно оборачивается быстротой выполне­ния. В данном случае жадный алгоритм выполняется за время О(n^2), где n - количество радиостанций.
А теперь посмотрим, как эта задача выглядит в программном коде.

### Подготовительный код
В этом примере для простоты будет использоваться небольшое подмноже­ство штатов и станций.

Сначала составим список штатов:
```JavaScript
    const statesNeeded = new Set("mt", "wa", "or", "id", "nv", "ut", "са", "az");
```
В этой реализации я использовал множество. Эта структура данных похо­жа на список, но каждый элемент может встречаться в множестве не более одного раза. Множества не содержат дубликатов. Предположим, имеется следующий список:
```JavaScript
let arr = [1, 2, 2, 3, 3, 3];
```
Этот список преобразуется в множество:
```JavaScript
new Set(1, 2, 2, 3, 3, 3); // 1, 2, 3
```
Значения 1, 2 и 3 встречаются в списке по одному разу.

Также понадобится список станций, из которого будет выбираться покры­тие. Я решил воспользоваться хешем:
```JavaScript
let stations = new Map();
stations.set("kone", new Set("id", "nv", "ut"));
stations.set("ktwo", new Set("wa", "id", "mt"));
stations.set("kthree", new Set("or", "nv", "ca"));
stations.set("kfour", new Set("nv", "ut"));
stations.set("kfive", new Set("ca", "az"));
```

Ключи - названия станций, а значения - сокращенные обозначения шта­тов, входящих в зону охвата. Таким образом, в данном примере станция kone вещает в штатах Айдахо (id), Невада (nv) и Юта (ut). Все значения являют­ся множествами. Как вы вскоре увидите, хранение данных во множествах упрощает работу.

Наконец, нам понадобится структура данных для хранения итогового на­бора станций:
```JavaScript
const final_stations = new Set() =
```

### Вычисление ответа