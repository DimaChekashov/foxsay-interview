## Алгоритм Дейкстры

**Работа с алгоритмом Дейкстры**
Посмотрим, как этот алгоритм работает с графом.

Каждому ребру назначается время перемещения в минутах. Алгоритм Дейкстры используется для поиска пути от начальной точки к конечной за кратчайшее возможное время.
Применив к этому графу поиск в ширину, вы получите следующий крат­чайший путь.
Этот путь занимает 7 минут. А может, существует путь, который займет меньше времени? Алгоритм Дейкстры состоит из четырех шагов:
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).
2. Обновить стоимости соседей этого узла (вскоре я объясню, что имеется в виду).
3. Повторять, пока это не будет сделано для всех узлов графа.
4. Вычислить итоговый путь.

**Шаг 1:** найти узел с наименьшей стоимостью. Вы стоите в самом начале и думаете, куда направиться: к узлу А или к узлу В. Сколько времени по­ надобится, чтобы добраться до каждого из этих узлов?

До узла А вы будете добираться 6 минут, а до узла В - 2 минуты. Что касается остальных узлов, мы о них пока ничего не знаем.

Так как время достижения конечного узла остается неизвестным, мы считаем, что оно бесконечно. Узел В - ближайший... он находится всего в 2 минутах.

**Шаг 2:** вычислить, сколько времени потребуется для того, чтобы добраться до всех соседей В *при переходе по ребру из В*.

Ого, да мы обнаружили более короткий путь к узлу А! Раньше для перехода к нему требовалось 6 минут.

А если идти через узел В, то существует путь, который занимает всего 5 минут!

Если вы нашли более короткий путь для соседа В, обновите его стоимость. В данном случае мы нашли:
* Более короткий путь к А (сокращение с 6 минут до 5 минут).
* Более короткий путь к конечному узлу (сокращение от бесконечности до 7 минут).

**Шаг 3:** повторяем!

**Снова шаr 1:** находим узел, для перехода к которому требуется наименьшее время. С узлом В работа закончена, поэтому наименьшую оценку времени имеет узел А.

**Снова шаr 2:** обновляем стоимости соседей А.

Путь до конечного узла теперь занимает всего 6 минут!

Алгоритм Дейкстры выполнен для каждого узла (выполнять его для конеч­ного узла не нужно). К этому моменту вам известно следующее:
* Чтобы добраться до узла В, нужно 2 минуты.
* Чтобы добраться до узла А, нужно 5 минут.
* Чтобы добраться до конечного узла, нужно 6 минут.

Последний шаг - вычисление итогового пути - откладывается до следую­щего раздела. А пока я просто покажу, как выглядит итоговый путь.

Алгоритм поиска в ширину не найдет этот путь как кратчайший, потому что он состоит из трех сегментов, а от начального узла до конечного можно добраться всего за два сегмента.

В предыдущей главе мы использовали поиск в ширину для нахождения кратчайшего пути между двумя точками. Тогда под «кратчайшим путем» понимался путь с минимальным количеством сегментов. С другой стороны, в алгоритме Дейкстры каждому сегменту присваивается число (вес), а ал­горитм Дейкстры находит путь с наименьшим суммарным весом.

На всякий случай повторим: алгоритм Дейкстры состоит из четырех шагов:
1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).
2. Проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимости.
3. Повторять, пока это не будет сделано для всех узлов графа.
4. Вычислить итоговый путь.

### Терминология
Я хочу привести еще несколько примеров применения алгоритма Дейкстры. Но сначала стоит немного разобраться с терминологией.

Когда вы работаете с алгоритмом Дейкстры, с каждым ребром графа свя­зывается число, *называемое весом*.

Граф с весами называется *взвешенным графом*. Граф без весов называется *невзвешенным графом*.

Для вычисления кратчайшего пути в невзвешенном графе используется поиск в ширину. Кратчайшие пути во взвешенном графе вычисляются по алгоритму Дейкстры. В графах также могут присутствовать циклы.

Это означает, что вы можете начать с некоторого узла, перемещаться по графу, а потом снова оказаться в том же узле. Предположим, вы ищете кратчайший путь в графе, содержащем цикл.

Есть ли смысл в перемещении по циклу? Что ж, вы можете использовать путь без прохождения цикла, а можете пройти по циклу.

Вы в любом случае оказываетесь в узле А, но цикл добавляет лишний вес. Вы даже можете обойти цикл дважды, если вдруг захотите.

Но каждый раз, когда вы проходите по циклу, вы только увеличиваете сум­марный вес на 8. Следовательно, путь с обходом цикла никогда не будет кратчайшим.

Наконец, вы еще не забыли наше обсуждение направленных и ненаправ­ленных графов.

Само понятие ненаправленного графа означает, что каждый из двух узлов фактически ведет к другому узлу. А это цикл!

В ненаправленном графе каждое новое ребро добавляет еще один цикл. Алгоритм Дейкстры работает только с *направленными ациклическими графами*, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph).

### История одного обмена
Но довольно терминологии, пора рассмотреть кон­кретный пример! Это Рама. Он хочет выменять свою книгу по музыке на пианино.

«Я тебе дам за книгу вот этот постер, - говорит Алекс. - Это моя любимая группа Destroyer. Или могу дать за книгу редкую пластинку Рика Эстли и еще $5». - «О, я слышала, что на этой пластинке есть отличные песни, - говорит Эми. - Готова отдать за постер или пластинку мою гитару или ударную установку».

Слушай я отдам тебе свое пианино за любую из вещей Эми.

Прекрасно! Рама с небольшими дополнительными тратами может поменять свою книгу на насто­ящее пианино. Теперь остается понять, как ему
потратить наименьшую сумму на цепочке обменов. Изобразим полученные им предложения в виде графа.

Узлы графа - это предметы, на которые может поменяться Рама. Веса ребер представляют сумму доплаты за обмен. Таким образом, Рама может поменять постер на гитару за $30 или же поменять пластинку на гитару за $15. Как Раме вычислить путь от книги до пианино, при котором он потратит наименьшую сумму? На помощь приходит алгоритм Дейкстры! Вспомните, что алгоритм Дейкстры состоит из четырех шагов. В этом при­ мере мы выполним все четыре шага, а в конце будет вычислен итоговый путь.

Прежде чем начинать, необходимо немного подготовиться. Постройте таблицу со стоимостями всех узлов. (Стоимость узла определяет затраты на его достижение.)

Таблица будет обновляться по мере работы алгоритма. Для вычисления итогового пути в таблицу также необходимо добавить столбец *родитель*.
Вскоре я покажу, как работает этот столбец. А пока просто запустим алго­ ритм.

**Шаг 1:** найти узел с наименьшей стоимостью. В данном случае самый де­шевый вариант обмена с доплатой $0 - это постер. Возможно ли получить постер с меньшими затратами? Это очень важный момент, хорошенько по­думайте над ним. Удастся ли вам найти серию обменов, при которой Рама получит постер менее чем за $0? Продолжайте читать, когда будете готовы ответить на вопрос. Правильный ответ: нет, не удастся. Так как постер явля­ется узлом с наименъшей стоимостъю, до которого может добратъся Рама, снизить его стоимость невозможно. На происходящее можно взглянуть иначе: предположим, вы едете из дома на работу.

Если вы выберете путь к школе, это займет 2 минуты. Если вы выберете путь к парку, это займет 6 минут. Существует ли путь, при котором вы вы­бираете путь к парку и оказываетесь в школе менее чем за 2 минуты? Это невозможно, потому что только для того, чтобы попасть в парк, потребует­ся более 2 минут. С другой стороны, можно ли найти более быстрый путь в парк? Да, можно.

В этом заключается ключевая идея алгоритма Дейкстры: *в графе ищется путъ с наименъшей стоимостъю. Пути к этому узлу с менъшими затратами не существует!*

Возвращаемся к музыкальному примеру. Вариант с постером обладает наи­меньшей стоимостью.

**Шаг 2:** Вычислить, сколько времени потребуется для того, чтобы добраться до всех его соседей (стоимость).

Стоимости бас-гитары и барабана заносятся в таблицу. Они были заданы при переходе через узел постера, поэтому постер указывается как их роди­тель. А это означает, что для того, чтобы добраться до бас-гитары, вы про­ ходите по ребру от постера; то же самое происходит с барабаном.

**Снова шаг 1:** пластинка - следующий по стоимости узел ($5).
**Снова шаг 2:** обновляются значения всех его соседей.

Смотрите, стоимости барабана и гитары обновились! Это означает, что к барабану и гитаре дешевле перейти через ребро, идущее от пластинки. Соответственно, пластинка назначается новым родителем обоих инстру­ментов.

Следующий по стоимости узел - бас-гитара. Обновите данные его со­ седей.

Хорошо, мы наконец-то вычислили стоимость для пианино при условии обмена гитары на пианино. Соответственно, гитара назначается родителем. Наконец, задается стоимость последнего узла - барабана.

Оказывается, Рама может получить пианино еще дешевле, поменяв удар­ ную установку на пианино. Таким образом, самая дешевая цепочка обменов обойдется Раме в $35.

Теперь, как я и обещал, необходимо вычислить итоговый путь. К этому моменту вы уже знаете, что кратчайший путь обойдется в $35, но как этот путь определить? Для начала возьмем родителя узла «пианино».
В качестве родителя узла «пианино» указан узел «барабан».
А в качестве родителя узла «барабан» указан узел «пластинка».

Следовательно, Рама обменивает пластинку на барабан. И конечно, в самом начале он меняет книгу на пластинку. Проходя по родительским узлам в об­ратном направлении, мы получаем полный путь.
Серия обменов, которую должен сделать Рама, выглядит так:
Книга => Пластинка
Пластинка => Барабан
Барабан => Пианино

До сих пор я использовал термин «кратчайший путь» более или менее буквально, понимая под ним вычисление кратчайшего пути между двумя точками или двумя людьми. Надеюсь, этот пример показал, что кратчайший путь далеко не всегда связывается с физическим расстоянием: он может быть направлен на минимизацию какой-либо характеристики. В нашем примере Рама хотел свести к минимуму свои затраты при обмене. Спасибо Дейкстре!

### Ребра с отрицательным весом
В предыдущем примере Алекс предложил в обмен на книгу один из двух предметов.

Предположим, Сара предложила обменять пла­ стинку на постер и при этом она еще и даст Раме $7. Рама ничего не тратит при этом обмене, вместо этого он получит $7. Как изобразить это предло­ жение на графе?

Ребро, ведущее от пластинки к постеру, имеет отрицательный вес! Если Рама пойдет на этот обмен, он получит $7. Теперь к постеру можно до­браться двумя способами.

А значит, во втором обмене появляется смысл - Рама получает $2!

Теперь, если вы помните, Рама может обменять постер на барабан. И здесь возможны два пути.

Второй путь обойдется на $2 дешевле, поэтому нужно выбрать этот путь, верно?

И знаете что? Если применить алгоритм Дейкстры к этому графу, Рама выберет неверный путь. Он пойдет по более длинному пути. Алгоритм Дейкстры не может использоваться при наличии ребер, имеющих отри­ цательный вес. Такие ребра нарушают работу алгоритма. Посмотрим, что произойдет, если попытаться применить алгоритм Дейкстры к этому графу. Все начинается с построения таблицы стоимостей.

Теперь найдем узел с наименьшей стоимостью и обновим стоимости его со­седей. В этом случае постер оказывается узлом с наименьшей стоимостью. Итак, в соответствии с алгоритмом Дейкстры, к постеру невозможно перейти более дешевым способом, чем с оплатой $0 (а вы знаете, что это неверно!) Как бы то ни было, обновим стоимости его соседей.

Получается, что теперь стоимость барабана составляет $35.

Перейдем к следующему по стоимости узлу, который еще не был обработан.

Обновим стоимости его соседей.

Узел **постер** уже был обработан, однако вы обновляете его стоимость. Это очень тревожный признак - обработка узла означает, что к нему невозможно добраться с меньшими затратами. Но вы только что нашли более дешевый путь к постеру! У барабана соседей нет, поэтому работа алгоритма завершена. Ниже приведены итоговые стоимости.

Чтобы добраться до барабанов, Раме потребовалось $35. Вы знаете, что существует путь, который стоит всего $33, но алгоритм Дейкстры его не на­ходит. Алгоритм Дейкстры предположил, что, поскольку вы обрабатываете узел «постер», к этому узлу невозможно добраться быстрее. Это предполо­жение работает только в том случае, если ребер с отрицательным весом не существует. Следовательно, использование алгоритма Дейкстры с графом, содержащим ребра с отрицательным весом, невозможно. Если вы хотите найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый алгоритмом Беллмана-Форда. Рассмотрение этого алгоритма выходит за рамки этой книги, но вы сможете найти хорошие описания в Интернете.

### Реализация
Посмотрим, как алгоритм Дейкстры реализуется в программном коде.

Для реализации этого примера понадобятся три хеш-таблицы.

Хеш-таблицы стоимостей и родителей будут обновляться по ходу работы алгоритма. Сначала необходимо реализовать граф. Как и в главе 6, для этого будет использована хеш-таблица:
```JavaScript
const graph = new Map();
```
В предыдущей главе все соседи узла были сохранены в хеш-таблице.

Но на этот раз необходимо сохранить как соседей, так и стоимость перехода к соседу. Предположим, у начального узла есть два соседа, А и В.

Как представить веса этих ребер? Почему бы не воспользоваться другой хеш-таблицей?
```JavaScript
graph.set("start", new Map());
graph.get("start").set("a", 6);
graph.get("start").set("b", 2);
```

Итак, graph.get("start") является хеш-таблицей. Для получения всех соседей начального узла можно воспользоваться следующим выражением:
```JavaScript
graph.get("start").keys(); // MapIterator {'a', 'b'}
```
Одно ребро ведет из начального узла в А, а другое - А если вы захотите узнать веса этих ребер?
```JavaScript
graph.get("start").get("a"); // 6

graph.get("start").get("b"); // 2
```
Включим в граф остальные узлы и их соседей:
```JavaScript
graph.set("a", new Map());
graph.get("a").set("fin", 1);
graph.set("b", new Map());
graph.get("b").set("a", 3);
graph.get("b").set("fin", 5);
graph.set("fin", new Map());
```

Также понадобится хеш-таблица для хранения стоимо­стей всех узлов.

Стоимость узла определяет, сколько времени потребуется для перехода к этому узлу от начального узла. Вы знаете, что переход от начального узла к узлу В занимает 2 минуты. Вы знаете, что для перехода к узлу А требует­ся 6 минут (хотя, возможно, вы найдете более быстрый путь). Вы не знаете, сколько времени потребуется для достижения конечного узла. Если стоимость еще неизвестна, она считается бесконечной. Можно ли представить бесконечность в JavaScript? Оказывается, можно:
```JavaScript
const infinity = Infinity;
```

Код создания таблицы стоимостей **costs**:
```JavaScript
const infinity = Infinity;
const costs = new Map();
costs.set("a", 6);
costs.set("b", 2);
costs.set("fin", infinity);
```

Для родителей также создается отдельная таблица:
```JavaScript
const parents = new Map();
parents.set("a", "start");
parents.set("b", "start");
parents.set("fin", null);
```
Наконец, вам нужен массив для отслеживания всех уже обработанных узлов, так как один узел не должен обрабатываться многократно:
```JavaScript
let processed = [];
```

На этом подготовка завершается. Теперь обратимся к алгоритму.

```JavaScript
const graph = new Map();

graph.set("start", new Map());
graph.get("start").set("a", 6);
graph.get("start").set("b", 2);
graph.set("a", new Map());
graph.get("a").set("fin", 1);
graph.set("b", new Map());
graph.get("b").set("a", 3);
graph.get("b").set("fin", 5);
graph.set("fin", new Map());

const infinity = Infinity;
const costs = new Map();
costs.set("a", 6);
costs.set("b", 2);
costs.set("fin", infinity);

const parents = new Map();
parents.set("a", "start");
parents.set("b", "start");
parents.set("fin", null);

let processed = [];

function find_lowest_cost_node(costs) {
    let lowest_cost = Infinity;
    let lowest_cost_node = null;

    for (let [node, cost] of costs) {
        if (cost < lowest_cost && !processed.includes(node)) {
            lowest_cost = cost;
            lowest_cost_node = node;
        }
    }

    return lowest_cost_node;
}

let node = find_lowest_cost_node(costs);
while (node !== null && node !== "fin") {
    let cost = costs.get(node);
    let neighbors = graph.get(node);

    for (let [n, neighborCost] of neighbors) {
        let new_cost = cost + neighborCost;

        if (costs.get(n) > new_cost) {
            costs.set(n, new_cost);
            parents.set(n, node);
        }
    }

    processed.push(node);

    node = find_lowest_cost_node(costs);
}

console.log("Shortest path to fin:", costs.get("fin")); // The shortest path to "fin" node
console.log("Parents map:", parents); // Map containing the shortest path from "start" to each node
```

### Шпаргалка
* Поиск в ширину вычисляет кратчайший путь в невзвешенном графе.
* Алгоритм Дейкстры вычисляет кратчайший путь во взвешенном графе.
* Алгоритм Дейкстры работает только в том случае, если все веса положительны.
* При наличии отрицательных весов используйте алгоритм Беллмана­ Форда.
